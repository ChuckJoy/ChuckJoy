<!DOCTYPE html>
<html>
    
    <head>
      <!--  Feature-Policy: microphone 'self'; camera 'self'; usb 'self'; autoplay 'self' ; -->

        <meta charset="utf-8">
        <meta http-equiv="Cache-Control" content="no-cache">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="mobile-web-app-capable" content="yes">

        <title>ArtOfMotion - WebGL Fluid Simulation</title>
        <meta name="description" content="A WebGL fluid simulation that works in mobile browsers.">

        <meta property="og:type" content="website">
        <meta property="og:title" content="Webgl Fluid Simulation">
        <meta property="og:description" content="A WebGL fluid simulation that works in mobile browsers.">
        <meta property="og:url" content="https://paveldogreat.github.io/WebGL-Fluid-Simulation/">

       <!-- <link rel="stylesheet" href="style.css"> -->
       
    
        <style>
            * {
                user-select: none;
                
            }

            html, body {
                overflow: hidden;
            }

            body {
                margin: 0;
                position: fixed;
                width: 100%;
                height: 100%;
            }

            canvas {
                width: 100%;
                height: 100%;
                background-size: cover;
                background-image: 'background_image.png';
                background-repeat: no-repeat;
                background-position: center;
            }

            fileupload  {
                position: absolute;
                top: 150px;
                color: white;
                z-index: 100;

            }
            container1 {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: black;
               
            }

            .dg {
                opacity: 1.0;
                color: #ebfa0c;
                background-color: #0cac21;
                background-color: #0ec280;
                color: rgb(109, 235, 41);
            }

            .dg .property-name {
                overflow: visible;
            }

            .bigFont {
                font-size: 150%;
                color: #8C8C8C;
            }

            .cr.function.appBigFont {
                font-size: 150%;
                line-height: 27px;
                background-color: #129696;
            }

            .cr.function.appBigFont .property-name {
                float: none;
            }

            .cr.function.appBigFont .icon {
                position: sticky;
                bottom: 27px;
            }
        </style>
          
        <!--<script type="text/javascript" src="dat.gui.min.js"></script>  -->  
        <script type="text/javascript" >
        /**
         * dat-gui JavaScript Controller Library
         * https://github.com/dataarts/dat.gui
         *
         * Copyright 2011 Data Arts Team, Google Creative Lab
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         */
        !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.dat={})}(this,function(e){"use strict";function t(e,t){var n=e.__state.conversionName.toString(),o=Math.round(e.r),i=Math.round(e.g),r=Math.round(e.b),s=e.a,a=Math.round(e.h),l=e.s.toFixed(1),d=e.v.toFixed(1);if(t||"THREE_CHAR_HEX"===n||"SIX_CHAR_HEX"===n){for(var c=e.hex.toString(16);c.length<6;)c="0"+c;return"#"+c}return"CSS_RGB"===n?"rgb("+o+","+i+","+r+")":"CSS_RGBA"===n?"rgba("+o+","+i+","+r+","+s+")":"HEX"===n?"0x"+e.hex.toString(16):"RGB_ARRAY"===n?"["+o+","+i+","+r+"]":"RGBA_ARRAY"===n?"["+o+","+i+","+r+","+s+"]":"RGB_OBJ"===n?"{r:"+o+",g:"+i+",b:"+r+"}":"RGBA_OBJ"===n?"{r:"+o+",g:"+i+",b:"+r+",a:"+s+"}":"HSV_OBJ"===n?"{h:"+a+",s:"+l+",v:"+d+"}":"HSVA_OBJ"===n?"{h:"+a+",s:"+l+",v:"+d+",a:"+s+"}":"unknown format"}function n(e,t,n){Object.defineProperty(e,t,{get:function(){return"RGB"===this.__state.space?this.__state[t]:(I.recalculateRGB(this,t,n),this.__state[t])},set:function(e){"RGB"!==this.__state.space&&(I.recalculateRGB(this,t,n),this.__state.space="RGB"),this.__state[t]=e}})}function o(e,t){Object.defineProperty(e,t,{get:function(){return"HSV"===this.__state.space?this.__state[t]:(I.recalculateHSV(this),this.__state[t])},set:function(e){"HSV"!==this.__state.space&&(I.recalculateHSV(this),this.__state.space="HSV"),this.__state[t]=e}})}function i(e){if("0"===e||S.isUndefined(e))return 0;var t=e.match(U);return S.isNull(t)?0:parseFloat(t[1])}function r(e){var t=e.toString();return t.indexOf(".")>-1?t.length-t.indexOf(".")-1:0}function s(e,t){var n=Math.pow(10,t);return Math.round(e*n)/n}function a(e,t,n,o,i){return o+(e-t)/(n-t)*(i-o)}function l(e,t,n,o){e.style.background="",S.each(ee,function(i){e.style.cssText+="background: "+i+"linear-gradient("+t+", "+n+" 0%, "+o+" 100%); "})}function d(e){e.style.background="",e.style.cssText+="background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",e.style.cssText+="background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",e.style.cssText+="background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",e.style.cssText+="background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",e.style.cssText+="background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"}function c(e,t,n){var o=document.createElement("li");return t&&o.appendChild(t),n?e.__ul.insertBefore(o,n):e.__ul.appendChild(o),e.onResize(),o}function u(e){X.unbind(window,"resize",e.__resizeHandler),e.saveToLocalStorageIfPossible&&X.unbind(window,"unload",e.saveToLocalStorageIfPossible)}function _(e,t){var n=e.__preset_select[e.__preset_select.selectedIndex];n.innerHTML=t?n.value+"*":n.value}function h(e,t,n){if(n.__li=t,n.__gui=e,S.extend(n,{options:function(t){if(arguments.length>1){var o=n.__li.nextElementSibling;return n.remove(),f(e,n.object,n.property,{before:o,factoryArgs:[S.toArray(arguments)]})}if(S.isArray(t)||S.isObject(t)){var i=n.__li.nextElementSibling;return n.remove(),f(e,n.object,n.property,{before:i,factoryArgs:[t]})}},name:function(e){return n.__li.firstElementChild.firstElementChild.innerHTML=e,n},listen:function(){return n.__gui.listen(n),n},remove:function(){return n.__gui.remove(n),n}}),n instanceof q){var o=new Q(n.object,n.property,{min:n.__min,max:n.__max,step:n.__step});S.each(["updateDisplay","onChange","onFinishChange","step","min","max"],function(e){var t=n[e],i=o[e];n[e]=o[e]=function(){var e=Array.prototype.slice.call(arguments);return i.apply(o,e),t.apply(n,e)}}),X.addClass(t,"has-slider"),n.domElement.insertBefore(o.domElement,n.domElement.firstElementChild)}else if(n instanceof Q){var i=function(t){if(S.isNumber(n.__min)&&S.isNumber(n.__max)){var o=n.__li.firstElementChild.firstElementChild.innerHTML,i=n.__gui.__listening.indexOf(n)>-1;n.remove();var r=f(e,n.object,n.property,{before:n.__li.nextElementSibling,factoryArgs:[n.__min,n.__max,n.__step]});return r.name(o),i&&r.listen(),r}return t};n.min=S.compose(i,n.min),n.max=S.compose(i,n.max)}else n instanceof K?(X.bind(t,"click",function(){X.fakeEvent(n.__checkbox,"click")}),X.bind(n.__checkbox,"click",function(e){e.stopPropagation()})):n instanceof Z?(X.bind(t,"click",function(){X.fakeEvent(n.__button,"click")}),X.bind(t,"mouseover",function(){X.addClass(n.__button,"hover")}),X.bind(t,"mouseout",function(){X.removeClass(n.__button,"hover")})):n instanceof $&&(X.addClass(t,"color"),n.updateDisplay=S.compose(function(e){return t.style.borderLeftColor=n.__color.toString(),e},n.updateDisplay),n.updateDisplay());n.setValue=S.compose(function(t){return e.getRoot().__preset_select&&n.isModified()&&_(e.getRoot(),!0),t},n.setValue)}function p(e,t){var n=e.getRoot(),o=n.__rememberedObjects.indexOf(t.object);if(-1!==o){var i=n.__rememberedObjectIndecesToControllers[o];if(void 0===i&&(i={},n.__rememberedObjectIndecesToControllers[o]=i),i[t.property]=t,n.load&&n.load.remembered){var r=n.load.remembered,s=void 0;if(r[e.preset])s=r[e.preset];else{if(!r[se])return;s=r[se]}if(s[o]&&void 0!==s[o][t.property]){var a=s[o][t.property];t.initialValue=a,t.setValue(a)}}}}function f(e,t,n,o){if(void 0===t[n])throw new Error('Object "'+t+'" has no property "'+n+'"');var i=void 0;if(o.color)i=new $(t,n);else{var r=[t,n].concat(o.factoryArgs);i=ne.apply(e,r)}o.before instanceof z&&(o.before=o.before.__li),p(e,i),X.addClass(i.domElement,"c");var s=document.createElement("span");X.addClass(s,"property-name"),s.innerHTML=i.property;var a=document.createElement("div");a.appendChild(s),a.appendChild(i.domElement);var l=c(e,a,o.before);return X.addClass(l,he.CLASS_CONTROLLER_ROW),i instanceof $?X.addClass(l,"color"):X.addClass(l,H(i.getValue())),h(e,l,i),e.__controllers.push(i),i}function m(e,t){return document.location.href+"."+t}function g(e,t,n){var o=document.createElement("option");o.innerHTML=t,o.value=t,e.__preset_select.appendChild(o),n&&(e.__preset_select.selectedIndex=e.__preset_select.length-1)}function b(e,t){t.style.display=e.useLocalStorage?"block":"none"}function v(e){var t=e.__save_row=document.createElement("li");X.addClass(e.domElement,"has-save"),e.__ul.insertBefore(t,e.__ul.firstChild),X.addClass(t,"save-row");var n=document.createElement("span");n.innerHTML="&nbsp;",X.addClass(n,"button gears");var o=document.createElement("span");o.innerHTML="Save",X.addClass(o,"button"),X.addClass(o,"save");var i=document.createElement("span");i.innerHTML="New",X.addClass(i,"button"),X.addClass(i,"save-as");var r=document.createElement("span");r.innerHTML="Revert",X.addClass(r,"button"),X.addClass(r,"revert");var s=e.__preset_select=document.createElement("select");if(e.load&&e.load.remembered?S.each(e.load.remembered,function(t,n){g(e,n,n===e.preset)}):g(e,se,!1),X.bind(s,"change",function(){for(var t=0;t<e.__preset_select.length;t++)e.__preset_select[t].innerHTML=e.__preset_select[t].value;e.preset=this.value}),t.appendChild(s),t.appendChild(n),t.appendChild(o),t.appendChild(i),t.appendChild(r),ae){var a=document.getElementById("dg-local-explain"),l=document.getElementById("dg-local-storage");document.getElementById("dg-save-locally").style.display="block","true"===localStorage.getItem(m(e,"isLocal"))&&l.setAttribute("checked","checked"),b(e,a),X.bind(l,"change",function(){e.useLocalStorage=!e.useLocalStorage,b(e,a)})}var d=document.getElementById("dg-new-constructor");X.bind(d,"keydown",function(e){!e.metaKey||67!==e.which&&67!==e.keyCode||le.hide()}),X.bind(n,"click",function(){d.innerHTML=JSON.stringify(e.getSaveObject(),void 0,2),le.show(),d.focus(),d.select()}),X.bind(o,"click",function(){e.save()}),X.bind(i,"click",function(){var t=prompt("Enter a new preset name.");t&&e.saveAs(t)}),X.bind(r,"click",function(){e.revert()})}function y(e){function t(t){return t.preventDefault(),e.width+=i-t.clientX,e.onResize(),i=t.clientX,!1}function n(){X.removeClass(e.__closeButton,he.CLASS_DRAG),X.unbind(window,"mousemove",t),X.unbind(window,"mouseup",n)}function o(o){return o.preventDefault(),i=o.clientX,X.addClass(e.__closeButton,he.CLASS_DRAG),X.bind(window,"mousemove",t),X.bind(window,"mouseup",n),!1}var i=void 0;e.__resize_handle=document.createElement("div"),S.extend(e.__resize_handle.style,{width:"6px",marginLeft:"-3px",height:"200px",cursor:"ew-resize",position:"absolute"}),X.bind(e.__resize_handle,"mousedown",o),X.bind(e.__closeButton,"mousedown",o),e.domElement.insertBefore(e.__resize_handle,e.domElement.firstElementChild)}function w(e,t){e.domElement.style.width=t+"px",e.__save_row&&e.autoPlace&&(e.__save_row.style.width=t+"px"),e.__closeButton&&(e.__closeButton.style.width=t+"px")}function x(e,t){var n={};return S.each(e.__rememberedObjects,function(o,i){var r={},s=e.__rememberedObjectIndecesToControllers[i];S.each(s,function(e,n){r[n]=t?e.initialValue:e.getValue()}),n[i]=r}),n}function E(e){for(var t=0;t<e.__preset_select.length;t++)e.__preset_select[t].value===e.preset&&(e.__preset_select.selectedIndex=t)}function C(e){0!==e.length&&oe.call(window,function(){C(e)}),S.each(e,function(e){e.updateDisplay()})}var A=Array.prototype.forEach,k=Array.prototype.slice,S={BREAK:{},extend:function(e){return this.each(k.call(arguments,1),function(t){(this.isObject(t)?Object.keys(t):[]).forEach(function(n){this.isUndefined(t[n])||(e[n]=t[n])}.bind(this))},this),e},defaults:function(e){return this.each(k.call(arguments,1),function(t){(this.isObject(t)?Object.keys(t):[]).forEach(function(n){this.isUndefined(e[n])&&(e[n]=t[n])}.bind(this))},this),e},compose:function(){var e=k.call(arguments);return function(){for(var t=k.call(arguments),n=e.length-1;n>=0;n--)t=[e[n].apply(this,t)];return t[0]}},each:function(e,t,n){if(e)if(A&&e.forEach&&e.forEach===A)e.forEach(t,n);else if(e.length===e.length+0){var o=void 0,i=void 0;for(o=0,i=e.length;o<i;o++)if(o in e&&t.call(n,e[o],o)===this.BREAK)return}else for(var r in e)if(t.call(n,e[r],r)===this.BREAK)return},defer:function(e){setTimeout(e,0)},debounce:function(e,t,n){var o=void 0;return function(){var i=this,r=arguments,s=n||!o;clearTimeout(o),o=setTimeout(function(){o=null,n||e.apply(i,r)},t),s&&e.apply(i,r)}},toArray:function(e){return e.toArray?e.toArray():k.call(e)},isUndefined:function(e){return void 0===e},isNull:function(e){return null===e},isNaN:function(e){function t(t){return e.apply(this,arguments)}return t.toString=function(){return e.toString()},t}(function(e){return isNaN(e)}),isArray:Array.isArray||function(e){return e.constructor===Array},isObject:function(e){return e===Object(e)},isNumber:function(e){return e===e+0},isString:function(e){return e===e+""},isBoolean:function(e){return!1===e||!0===e},isFunction:function(e){return e instanceof Function}},O=[{litmus:S.isString,conversions:{THREE_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return null!==t&&{space:"HEX",hex:parseInt("0x"+t[1].toString()+t[1].toString()+t[2].toString()+t[2].toString()+t[3].toString()+t[3].toString(),0)}},write:t},SIX_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9]{6})$/i);return null!==t&&{space:"HEX",hex:parseInt("0x"+t[1].toString(),0)}},write:t},CSS_RGB:{read:function(e){var t=e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return null!==t&&{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3])}},write:t},CSS_RGBA:{read:function(e){var t=e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return null!==t&&{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3]),a:parseFloat(t[4])}},write:t}}},{litmus:S.isNumber,conversions:{HEX:{read:function(e){return{space:"HEX",hex:e,conversionName:"HEX"}},write:function(e){return e.hex}}}},{litmus:S.isArray,conversions:{RGB_ARRAY:{read:function(e){return 3===e.length&&{space:"RGB",r:e[0],g:e[1],b:e[2]}},write:function(e){return[e.r,e.g,e.b]}},RGBA_ARRAY:{read:function(e){return 4===e.length&&{space:"RGB",r:e[0],g:e[1],b:e[2],a:e[3]}},write:function(e){return[e.r,e.g,e.b,e.a]}}}},{litmus:S.isObject,conversions:{RGBA_OBJ:{read:function(e){return!!(S.isNumber(e.r)&&S.isNumber(e.g)&&S.isNumber(e.b)&&S.isNumber(e.a))&&{space:"RGB",r:e.r,g:e.g,b:e.b,a:e.a}},write:function(e){return{r:e.r,g:e.g,b:e.b,a:e.a}}},RGB_OBJ:{read:function(e){return!!(S.isNumber(e.r)&&S.isNumber(e.g)&&S.isNumber(e.b))&&{space:"RGB",r:e.r,g:e.g,b:e.b}},write:function(e){return{r:e.r,g:e.g,b:e.b}}},HSVA_OBJ:{read:function(e){return!!(S.isNumber(e.h)&&S.isNumber(e.s)&&S.isNumber(e.v)&&S.isNumber(e.a))&&{space:"HSV",h:e.h,s:e.s,v:e.v,a:e.a}},write:function(e){return{h:e.h,s:e.s,v:e.v,a:e.a}}},HSV_OBJ:{read:function(e){return!!(S.isNumber(e.h)&&S.isNumber(e.s)&&S.isNumber(e.v))&&{space:"HSV",h:e.h,s:e.s,v:e.v}},write:function(e){return{h:e.h,s:e.s,v:e.v}}}}}],T=void 0,L=void 0,R=function(){L=!1;var e=arguments.length>1?S.toArray(arguments):arguments[0];return S.each(O,function(t){if(t.litmus(e))return S.each(t.conversions,function(t,n){if(T=t.read(e),!1===L&&!1!==T)return L=T,T.conversionName=n,T.conversion=t,S.BREAK}),S.BREAK}),L},B=void 0,N={hsv_to_rgb:function(e,t,n){var o=Math.floor(e/60)%6,i=e/60-Math.floor(e/60),r=n*(1-t),s=n*(1-i*t),a=n*(1-(1-i)*t),l=[[n,a,r],[s,n,r],[r,n,a],[r,s,n],[a,r,n],[n,r,s]][o];return{r:255*l[0],g:255*l[1],b:255*l[2]}},rgb_to_hsv:function(e,t,n){var o=Math.min(e,t,n),i=Math.max(e,t,n),r=i-o,s=void 0,a=void 0;return 0===i?{h:NaN,s:0,v:0}:(a=r/i,s=e===i?(t-n)/r:t===i?2+(n-e)/r:4+(e-t)/r,(s/=6)<0&&(s+=1),{h:360*s,s:a,v:i/255})},rgb_to_hex:function(e,t,n){var o=this.hex_with_component(0,2,e);return o=this.hex_with_component(o,1,t),o=this.hex_with_component(o,0,n)},component_from_hex:function(e,t){return e>>8*t&255},hex_with_component:function(e,t,n){return n<<(B=8*t)|e&~(255<<B)}},H="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},F=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},P=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),D=function e(t,n,o){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,n);if(void 0===i){var r=Object.getPrototypeOf(t);return null===r?void 0:e(r,n,o)}if("value"in i)return i.value;var s=i.get;if(void 0!==s)return s.call(o)},j=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)},V=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t},I=function(){function e(){if(F(this,e),this.__state=R.apply(this,arguments),!1===this.__state)throw new Error("Failed to interpret color arguments");this.__state.a=this.__state.a||1}return P(e,[{key:"toString",value:function(){return t(this)}},{key:"toHexString",value:function(){return t(this,!0)}},{key:"toOriginal",value:function(){return this.__state.conversion.write(this)}}]),e}();I.recalculateRGB=function(e,t,n){if("HEX"===e.__state.space)e.__state[t]=N.component_from_hex(e.__state.hex,n);else{if("HSV"!==e.__state.space)throw new Error("Corrupted color state");S.extend(e.__state,N.hsv_to_rgb(e.__state.h,e.__state.s,e.__state.v))}},I.recalculateHSV=function(e){var t=N.rgb_to_hsv(e.r,e.g,e.b);S.extend(e.__state,{s:t.s,v:t.v}),S.isNaN(t.h)?S.isUndefined(e.__state.h)&&(e.__state.h=0):e.__state.h=t.h},I.COMPONENTS=["r","g","b","h","s","v","hex","a"],n(I.prototype,"r",2),n(I.prototype,"g",1),n(I.prototype,"b",0),o(I.prototype,"h"),o(I.prototype,"s"),o(I.prototype,"v"),Object.defineProperty(I.prototype,"a",{get:function(){return this.__state.a},set:function(e){this.__state.a=e}}),Object.defineProperty(I.prototype,"hex",{get:function(){return"HEX"!==this.__state.space&&(this.__state.hex=N.rgb_to_hex(this.r,this.g,this.b),this.__state.space="HEX"),this.__state.hex},set:function(e){this.__state.space="HEX",this.__state.hex=e}});var z=function(){function e(t,n){F(this,e),this.initialValue=t[n],this.domElement=document.createElement("div"),this.object=t,this.property=n,this.__onChange=void 0,this.__onFinishChange=void 0}return P(e,[{key:"onChange",value:function(e){return this.__onChange=e,this}},{key:"onFinishChange",value:function(e){return this.__onFinishChange=e,this}},{key:"setValue",value:function(e){return this.object[this.property]=e,this.__onChange&&this.__onChange.call(this,e),this.updateDisplay(),this}},{key:"getValue",value:function(){return this.object[this.property]}},{key:"updateDisplay",value:function(){return this}},{key:"isModified",value:function(){return this.initialValue!==this.getValue()}}]),e}(),M={HTMLEvents:["change"],MouseEvents:["click","mousemove","mousedown","mouseup","mouseover"],KeyboardEvents:["keydown"]},G={};S.each(M,function(e,t){S.each(e,function(e){G[e]=t})});var U=/(\d+(\.\d+)?)px/,X={makeSelectable:function(e,t){void 0!==e&&void 0!==e.style&&(e.onselectstart=t?function(){return!1}:function(){},e.style.MozUserSelect=t?"auto":"none",e.style.KhtmlUserSelect=t?"auto":"none",e.unselectable=t?"on":"off")},makeFullscreen:function(e,t,n){var o=n,i=t;S.isUndefined(i)&&(i=!0),S.isUndefined(o)&&(o=!0),e.style.position="absolute",i&&(e.style.left=0,e.style.right=0),o&&(e.style.top=0,e.style.bottom=0)},fakeEvent:function(e,t,n,o){var i=n||{},r=G[t];if(!r)throw new Error("Event type "+t+" not supported.");var s=document.createEvent(r);switch(r){case"MouseEvents":var a=i.x||i.clientX||0,l=i.y||i.clientY||0;s.initMouseEvent(t,i.bubbles||!1,i.cancelable||!0,window,i.clickCount||1,0,0,a,l,!1,!1,!1,!1,0,null);break;case"KeyboardEvents":var d=s.initKeyboardEvent||s.initKeyEvent;S.defaults(i,{cancelable:!0,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,keyCode:void 0,charCode:void 0}),d(t,i.bubbles||!1,i.cancelable,window,i.ctrlKey,i.altKey,i.shiftKey,i.metaKey,i.keyCode,i.charCode);break;default:s.initEvent(t,i.bubbles||!1,i.cancelable||!0)}S.defaults(s,o),e.dispatchEvent(s)},bind:function(e,t,n,o){var i=o||!1;return e.addEventListener?e.addEventListener(t,n,i):e.attachEvent&&e.attachEvent("on"+t,n),X},unbind:function(e,t,n,o){var i=o||!1;return e.removeEventListener?e.removeEventListener(t,n,i):e.detachEvent&&e.detachEvent("on"+t,n),X},addClass:function(e,t){if(void 0===e.className)e.className=t;else if(e.className!==t){var n=e.className.split(/ +/);-1===n.indexOf(t)&&(n.push(t),e.className=n.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return X},removeClass:function(e,t){if(t)if(e.className===t)e.removeAttribute("class");else{var n=e.className.split(/ +/),o=n.indexOf(t);-1!==o&&(n.splice(o,1),e.className=n.join(" "))}else e.className=void 0;return X},hasClass:function(e,t){return new RegExp("(?:^|\\s+)"+t+"(?:\\s+|$)").test(e.className)||!1},getWidth:function(e){var t=getComputedStyle(e);return i(t["border-left-width"])+i(t["border-right-width"])+i(t["padding-left"])+i(t["padding-right"])+i(t.width)},getHeight:function(e){var t=getComputedStyle(e);return i(t["border-top-width"])+i(t["border-bottom-width"])+i(t["padding-top"])+i(t["padding-bottom"])+i(t.height)},getOffset:function(e){var t=e,n={left:0,top:0};if(t.offsetParent)do{n.left+=t.offsetLeft,n.top+=t.offsetTop,t=t.offsetParent}while(t);return n},isActive:function(e){return e===document.activeElement&&(e.type||e.href)}},K=function(e){function t(e,n){F(this,t);var o=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n)),i=o;return o.__prev=o.getValue(),o.__checkbox=document.createElement("input"),o.__checkbox.setAttribute("type","checkbox"),X.bind(o.__checkbox,"change",function(){i.setValue(!i.__prev)},!1),o.domElement.appendChild(o.__checkbox),o.updateDisplay(),o}return j(t,z),P(t,[{key:"setValue",value:function(e){var n=D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"setValue",this).call(this,e);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),this.__prev=this.getValue(),n}},{key:"updateDisplay",value:function(){return!0===this.getValue()?(this.__checkbox.setAttribute("checked","checked"),this.__checkbox.checked=!0,this.__prev=!0):(this.__checkbox.checked=!1,this.__prev=!1),D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updateDisplay",this).call(this)}}]),t}(),Y=function(e){function t(e,n,o){F(this,t);var i=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n)),r=o,s=i;if(i.__select=document.createElement("select"),S.isArray(r)){var a={};S.each(r,function(e){a[e]=e}),r=a}return S.each(r,function(e,t){var n=document.createElement("option");n.innerHTML=t,n.setAttribute("value",e),s.__select.appendChild(n)}),i.updateDisplay(),X.bind(i.__select,"change",function(){var e=this.options[this.selectedIndex].value;s.setValue(e)}),i.domElement.appendChild(i.__select),i}return j(t,z),P(t,[{key:"setValue",value:function(e){var n=D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"setValue",this).call(this,e);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),n}},{key:"updateDisplay",value:function(){return X.isActive(this.__select)?this:(this.__select.value=this.getValue(),D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updateDisplay",this).call(this))}}]),t}(),J=function(e){function t(e,n){function o(){r.setValue(r.__input.value)}F(this,t);var i=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n)),r=i;return i.__input=document.createElement("input"),i.__input.setAttribute("type","text"),X.bind(i.__input,"keyup",o),X.bind(i.__input,"change",o),X.bind(i.__input,"blur",function(){r.__onFinishChange&&r.__onFinishChange.call(r,r.getValue())}),X.bind(i.__input,"keydown",function(e){13===e.keyCode&&this.blur()}),i.updateDisplay(),i.domElement.appendChild(i.__input),i}return j(t,z),P(t,[{key:"updateDisplay",value:function(){return X.isActive(this.__input)||(this.__input.value=this.getValue()),D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updateDisplay",this).call(this)}}]),t}(),W=function(e){function t(e,n,o){F(this,t);var i=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n)),s=o||{};return i.__min=s.min,i.__max=s.max,i.__step=s.step,S.isUndefined(i.__step)?0===i.initialValue?i.__impliedStep=1:i.__impliedStep=Math.pow(10,Math.floor(Math.log(Math.abs(i.initialValue))/Math.LN10))/10:i.__impliedStep=i.__step,i.__precision=r(i.__impliedStep),i}return j(t,z),P(t,[{key:"setValue",value:function(e){var n=e;return void 0!==this.__min&&n<this.__min?n=this.__min:void 0!==this.__max&&n>this.__max&&(n=this.__max),void 0!==this.__step&&n%this.__step!=0&&(n=Math.round(n/this.__step)*this.__step),D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"setValue",this).call(this,n)}},{key:"min",value:function(e){return this.__min=e,this}},{key:"max",value:function(e){return this.__max=e,this}},{key:"step",value:function(e){return this.__step=e,this.__impliedStep=e,this.__precision=r(e),this}}]),t}(),Q=function(e){function t(e,n,o){function i(){l.__onFinishChange&&l.__onFinishChange.call(l,l.getValue())}function r(e){var t=d-e.clientY;l.setValue(l.getValue()+t*l.__impliedStep),d=e.clientY}function s(){X.unbind(window,"mousemove",r),X.unbind(window,"mouseup",s),i()}F(this,t);var a=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n,o));a.__truncationSuspended=!1;var l=a,d=void 0;return a.__input=document.createElement("input"),a.__input.setAttribute("type","text"),X.bind(a.__input,"change",function(){var e=parseFloat(l.__input.value);S.isNaN(e)||l.setValue(e)}),X.bind(a.__input,"blur",function(){i()}),X.bind(a.__input,"mousedown",function(e){X.bind(window,"mousemove",r),X.bind(window,"mouseup",s),d=e.clientY}),X.bind(a.__input,"keydown",function(e){13===e.keyCode&&(l.__truncationSuspended=!0,this.blur(),l.__truncationSuspended=!1,i())}),a.updateDisplay(),a.domElement.appendChild(a.__input),a}return j(t,W),P(t,[{key:"updateDisplay",value:function(){return this.__input.value=this.__truncationSuspended?this.getValue():s(this.getValue(),this.__precision),D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updateDisplay",this).call(this)}}]),t}(),q=function(e){function t(e,n,o,i,r){function s(e){e.preventDefault();var t=_.__background.getBoundingClientRect();return _.setValue(a(e.clientX,t.left,t.right,_.__min,_.__max)),!1}function l(){X.unbind(window,"mousemove",s),X.unbind(window,"mouseup",l),_.__onFinishChange&&_.__onFinishChange.call(_,_.getValue())}function d(e){var t=e.touches[0].clientX,n=_.__background.getBoundingClientRect();_.setValue(a(t,n.left,n.right,_.__min,_.__max))}function c(){X.unbind(window,"touchmove",d),X.unbind(window,"touchend",c),_.__onFinishChange&&_.__onFinishChange.call(_,_.getValue())}F(this,t);var u=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n,{min:o,max:i,step:r})),_=u;return u.__background=document.createElement("div"),u.__foreground=document.createElement("div"),X.bind(u.__background,"mousedown",function(e){document.activeElement.blur(),X.bind(window,"mousemove",s),X.bind(window,"mouseup",l),s(e)}),X.bind(u.__background,"touchstart",function(e){1===e.touches.length&&(X.bind(window,"touchmove",d),X.bind(window,"touchend",c),d(e))}),X.addClass(u.__background,"slider"),X.addClass(u.__foreground,"slider-fg"),u.updateDisplay(),u.__background.appendChild(u.__foreground),u.domElement.appendChild(u.__background),u}return j(t,W),P(t,[{key:"updateDisplay",value:function(){var e=(this.getValue()-this.__min)/(this.__max-this.__min);return this.__foreground.style.width=100*e+"%",D(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"updateDisplay",this).call(this)}}]),t}(),Z=function(e){function t(e,n,o){F(this,t);var i=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n)),r=i;return i.__button=document.createElement("div"),i.__button.innerHTML=void 0===o?"Fire":o,X.bind(i.__button,"click",function(e){return e.preventDefault(),r.fire(),!1}),X.addClass(i.__button,"button"),i.domElement.appendChild(i.__button),i}return j(t,z),P(t,[{key:"fire",value:function(){this.__onChange&&this.__onChange.call(this),this.getValue().call(this.object),this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue())}}]),t}(),$=function(e){function t(e,n){function o(e){u(e),X.bind(window,"mousemove",u),X.bind(window,"touchmove",u),X.bind(window,"mouseup",r),X.bind(window,"touchend",r)}function i(e){_(e),X.bind(window,"mousemove",_),X.bind(window,"touchmove",_),X.bind(window,"mouseup",s),X.bind(window,"touchend",s)}function r(){X.unbind(window,"mousemove",u),X.unbind(window,"touchmove",u),X.unbind(window,"mouseup",r),X.unbind(window,"touchend",r),c()}function s(){X.unbind(window,"mousemove",_),X.unbind(window,"touchmove",_),X.unbind(window,"mouseup",s),X.unbind(window,"touchend",s),c()}function a(){var e=R(this.value);!1!==e?(p.__color.__state=e,p.setValue(p.__color.toOriginal())):this.value=p.__color.toString()}function c(){p.__onFinishChange&&p.__onFinishChange.call(p,p.__color.toOriginal())}function u(e){-1===e.type.indexOf("touch")&&e.preventDefault();var t=p.__saturation_field.getBoundingClientRect(),n=e.touches&&e.touches[0]||e,o=n.clientX,i=n.clientY,r=(o-t.left)/(t.right-t.left),s=1-(i-t.top)/(t.bottom-t.top);return s>1?s=1:s<0&&(s=0),r>1?r=1:r<0&&(r=0),p.__color.v=s,p.__color.s=r,p.setValue(p.__color.toOriginal()),!1}function _(e){-1===e.type.indexOf("touch")&&e.preventDefault();var t=p.__hue_field.getBoundingClientRect(),n=1-((e.touches&&e.touches[0]||e).clientY-t.top)/(t.bottom-t.top);return n>1?n=1:n<0&&(n=0),p.__color.h=360*n,p.setValue(p.__color.toOriginal()),!1}F(this,t);var h=V(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,n));h.__color=new I(h.getValue()),h.__temp=new I(0);var p=h;h.domElement=document.createElement("div"),X.makeSelectable(h.domElement,!1),h.__selector=document.createElement("div"),h.__selector.className="selector",h.__saturation_field=document.createElement("div"),h.__saturation_field.className="saturation-field",h.__field_knob=document.createElement("div"),h.__field_knob.className="field-knob",h.__field_knob_border="2px solid ",h.__hue_knob=document.createElement("div"),h.__hue_knob.className="hue-knob",h.__hue_field=document.createElement("div"),h.__hue_field.className="hue-field",h.__input=document.createElement("input"),h.__input.type="text",h.__input_textShadow="0 1px 1px ",X.bind(h.__input,"keydown",function(e){13===e.keyCode&&a.call(this)}),X.bind(h.__input,"blur",a),X.bind(h.__selector,"mousedown",function(){X.addClass(this,"drag").bind(window,"mouseup",function(){X.removeClass(p.__selector,"drag")})}),X.bind(h.__selector,"touchstart",function(){X.addClass(this,"drag").bind(window,"touchend",function(){X.removeClass(p.__selector,"drag")})});var f=document.createElement("div");return S.extend(h.__selector.style,{width:"122px",height:"102px",padding:"3px",backgroundColor:"#222",boxShadow:"0px 1px 3px rgba(0,0,0,0.3)"}),S.extend(h.__field_knob.style,{position:"absolute",width:"12px",height:"12px",border:h.__field_knob_border+(h.__color.v<.5?"#fff":"#000"),boxShadow:"0px 1px 3px rgba(0,0,0,0.5)",borderRadius:"12px",zIndex:1}),S.extend(h.__hue_knob.style,{position:"absolute",width:"15px",height:"2px",borderRight:"4px solid #fff",zIndex:1}),S.extend(h.__saturation_field.style,{width:"100px",height:"100px",border:"1px solid #555",marginRight:"3px",display:"inline-block",cursor:"pointer"}),S.extend(f.style,{width:"100%",height:"100%",background:"none"}),l(f,"top","rgba(0,0,0,0)","#000"),S.extend(h.__hue_field.style,{width:"15px",height:"100px",border:"1px solid #555",cursor:"ns-resize",position:"absolute",top:"3px",right:"3px"}),d(h.__hue_field),S.extend(h.__input.style,{outline:"none",textAlign:"center",color:"#fff",border:0,fontWeight:"bold",textShadow:h.__input_textShadow+"rgba(0,0,0,0.7)"}),X.bind(h.__saturation_field,"mousedown",o),X.bind(h.__saturation_field,"touchstart",o),X.bind(h.__field_knob,"mousedown",o),X.bind(h.__field_knob,"touchstart",o),X.bind(h.__hue_field,"mousedown",i),X.bind(h.__hue_field,"touchstart",i),h.__saturation_field.appendChild(f),h.__selector.appendChild(h.__field_knob),h.__selector.appendChild(h.__saturation_field),h.__selector.appendChild(h.__hue_field),h.__hue_field.appendChild(h.__hue_knob),h.domElement.appendChild(h.__input),h.domElement.appendChild(h.__selector),h.updateDisplay(),h}return j(t,z),P(t,[{key:"updateDisplay",value:function(){var e=R(this.getValue());if(!1!==e){var t=!1;S.each(I.COMPONENTS,function(n){if(!S.isUndefined(e[n])&&!S.isUndefined(this.__color.__state[n])&&e[n]!==this.__color.__state[n])return t=!0,{}},this),t&&S.extend(this.__color.__state,e)}S.extend(this.__temp.__state,this.__color.__state),this.__temp.a=1;var n=this.__color.v<.5||this.__color.s>.5?255:0,o=255-n;S.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+"px",marginTop:100*(1-this.__color.v)-7+"px",backgroundColor:this.__temp.toHexString(),border:this.__field_knob_border+"rgb("+n+","+n+","+n+")"}),this.__hue_knob.style.marginTop=100*(1-this.__color.h/360)+"px",this.__temp.s=1,this.__temp.v=1,l(this.__saturation_field,"left","#fff",this.__temp.toHexString()),this.__input.value=this.__color.toString(),S.extend(this.__input.style,{backgroundColor:this.__color.toHexString(),color:"rgb("+n+","+n+","+n+")",textShadow:this.__input_textShadow+"rgba("+o+","+o+","+o+",.7)"})}}]),t}(),ee=["-moz-","-o-","-webkit-","-ms-",""],te={load:function(e,t){var n=t||document,o=n.createElement("link");o.type="text/css",o.rel="stylesheet",o.href=e,n.getElementsByTagName("head")[0].appendChild(o)},inject:function(e,t){var n=t||document,o=document.createElement("style");o.type="text/css",o.innerHTML=e;var i=n.getElementsByTagName("head")[0];try{i.appendChild(o)}catch(e){}}},ne=function(e,t){var n=e[t];return S.isArray(arguments[2])||S.isObject(arguments[2])?new Y(e,t,arguments[2]):S.isNumber(n)?S.isNumber(arguments[2])&&S.isNumber(arguments[3])?S.isNumber(arguments[4])?new q(e,t,arguments[2],arguments[3],arguments[4]):new q(e,t,arguments[2],arguments[3]):S.isNumber(arguments[4])?new Q(e,t,{min:arguments[2],max:arguments[3],step:arguments[4]}):new Q(e,t,{min:arguments[2],max:arguments[3]}):S.isString(n)?new J(e,t):S.isFunction(n)?new Z(e,t,""):S.isBoolean(n)?new K(e,t):null},oe=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},ie=function(){function e(){F(this,e),this.backgroundElement=document.createElement("div"),S.extend(this.backgroundElement.style,{backgroundColor:"rgba(0,0,0,0.8)",top:0,left:0,display:"none",zIndex:"1000",opacity:0,WebkitTransition:"opacity 0.2s linear",transition:"opacity 0.2s linear"}),X.makeFullscreen(this.backgroundElement),this.backgroundElement.style.position="fixed",this.domElement=document.createElement("div"),S.extend(this.domElement.style,{position:"fixed",display:"none",zIndex:"1001",opacity:0,WebkitTransition:"-webkit-transform 0.2s ease-out, opacity 0.2s linear",transition:"transform 0.2s ease-out, opacity 0.2s linear"}),document.body.appendChild(this.backgroundElement),document.body.appendChild(this.domElement);var t=this;X.bind(this.backgroundElement,"click",function(){t.hide()})}return P(e,[{key:"show",value:function(){var e=this;this.backgroundElement.style.display="block",this.domElement.style.display="block",this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)",this.layout(),S.defer(function(){e.backgroundElement.style.opacity=1,e.domElement.style.opacity=1,e.domElement.style.webkitTransform="scale(1)"})}},{key:"hide",value:function(){var e=this,t=function t(){e.domElement.style.display="none",e.backgroundElement.style.display="none",X.unbind(e.domElement,"webkitTransitionEnd",t),X.unbind(e.domElement,"transitionend",t),X.unbind(e.domElement,"oTransitionEnd",t)};X.bind(this.domElement,"webkitTransitionEnd",t),X.bind(this.domElement,"transitionend",t),X.bind(this.domElement,"oTransitionEnd",t),this.backgroundElement.style.opacity=0,this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)"}},{key:"layout",value:function(){this.domElement.style.left=window.innerWidth/2-X.getWidth(this.domElement)/2+"px",this.domElement.style.top=window.innerHeight/2-X.getHeight(this.domElement)/2+"px"}}]),e}(),re=function(e){if(e&&"undefined"!=typeof window){var t=document.createElement("style");return t.setAttribute("type","text/css"),t.innerHTML=e,document.head.appendChild(t),e}}(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");te.inject(re);var se="Default",ae=function(){try{return!!window.localStorage}catch(e){return!1}}(),le=void 0,de=!0,ce=void 0,ue=!1,_e=[],he=function e(t){var n=this,o=t||{};this.domElement=document.createElement("div"),this.__ul=document.createElement("ul"),this.domElement.appendChild(this.__ul),X.addClass(this.domElement,"dg"),this.__folders={},this.__controllers=[],this.__rememberedObjects=[],this.__rememberedObjectIndecesToControllers=[],this.__listening=[],o=S.defaults(o,{closeOnTop:!1,autoPlace:!0,width:e.DEFAULT_WIDTH}),o=S.defaults(o,{resizable:o.autoPlace,hideable:o.autoPlace}),S.isUndefined(o.load)?o.load={preset:se}:o.preset&&(o.load.preset=o.preset),S.isUndefined(o.parent)&&o.hideable&&_e.push(this),o.resizable=S.isUndefined(o.parent)&&o.resizable,o.autoPlace&&S.isUndefined(o.scrollable)&&(o.scrollable=!0);var i=ae&&"true"===localStorage.getItem(m(this,"isLocal")),r=void 0,s=void 0;if(Object.defineProperties(this,{parent:{get:function(){return o.parent}},scrollable:{get:function(){return o.scrollable}},autoPlace:{get:function(){return o.autoPlace}},closeOnTop:{get:function(){return o.closeOnTop}},preset:{get:function(){return n.parent?n.getRoot().preset:o.load.preset},set:function(e){n.parent?n.getRoot().preset=e:o.load.preset=e,E(this),n.revert()}},width:{get:function(){return o.width},set:function(e){o.width=e,w(n,e)}},name:{get:function(){return o.name},set:function(e){o.name=e,s&&(s.innerHTML=o.name)}},closed:{get:function(){return o.closed},set:function(t){o.closed=t,o.closed?X.addClass(n.__ul,e.CLASS_CLOSED):X.removeClass(n.__ul,e.CLASS_CLOSED),this.onResize(),n.__closeButton&&(n.__closeButton.innerHTML=t?e.TEXT_OPEN:e.TEXT_CLOSED)}},load:{get:function(){return o.load}},useLocalStorage:{get:function(){return i},set:function(e){ae&&(i=e,e?X.bind(window,"unload",r):X.unbind(window,"unload",r),localStorage.setItem(m(n,"isLocal"),e))}}}),S.isUndefined(o.parent)){if(this.closed=o.closed||!1,X.addClass(this.domElement,e.CLASS_MAIN),X.makeSelectable(this.domElement,!1),ae&&i){n.useLocalStorage=!0;var a=localStorage.getItem(m(this,"gui"));a&&(o.load=JSON.parse(a))}this.__closeButton=document.createElement("div"),this.__closeButton.innerHTML=e.TEXT_CLOSED,X.addClass(this.__closeButton,e.CLASS_CLOSE_BUTTON),o.closeOnTop?(X.addClass(this.__closeButton,e.CLASS_CLOSE_TOP),this.domElement.insertBefore(this.__closeButton,this.domElement.childNodes[0])):(X.addClass(this.__closeButton,e.CLASS_CLOSE_BOTTOM),this.domElement.appendChild(this.__closeButton)),X.bind(this.__closeButton,"click",function(){n.closed=!n.closed})}else{void 0===o.closed&&(o.closed=!0);var l=document.createTextNode(o.name);X.addClass(l,"controller-name"),s=c(n,l);X.addClass(this.__ul,e.CLASS_CLOSED),X.addClass(s,"title"),X.bind(s,"click",function(e){return e.preventDefault(),n.closed=!n.closed,!1}),o.closed||(this.closed=!1)}o.autoPlace&&(S.isUndefined(o.parent)&&(de&&(ce=document.createElement("div"),X.addClass(ce,"dg"),X.addClass(ce,e.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(ce),de=!1),ce.appendChild(this.domElement),X.addClass(this.domElement,e.CLASS_AUTO_PLACE)),this.parent||w(n,o.width)),this.__resizeHandler=function(){n.onResizeDebounced()},X.bind(window,"resize",this.__resizeHandler),X.bind(this.__ul,"webkitTransitionEnd",this.__resizeHandler),X.bind(this.__ul,"transitionend",this.__resizeHandler),X.bind(this.__ul,"oTransitionEnd",this.__resizeHandler),this.onResize(),o.resizable&&y(this),r=function(){ae&&"true"===localStorage.getItem(m(n,"isLocal"))&&localStorage.setItem(m(n,"gui"),JSON.stringify(n.getSaveObject()))},this.saveToLocalStorageIfPossible=r,o.parent||function(){var e=n.getRoot();e.width+=1,S.defer(function(){e.width-=1})}()};he.toggleHide=function(){ue=!ue,S.each(_e,function(e){e.domElement.style.display=ue?"none":""})},he.CLASS_AUTO_PLACE="a",he.CLASS_AUTO_PLACE_CONTAINER="ac",he.CLASS_MAIN="main",he.CLASS_CONTROLLER_ROW="cr",he.CLASS_TOO_TALL="taller-than-window",he.CLASS_CLOSED="closed",he.CLASS_CLOSE_BUTTON="close-button",he.CLASS_CLOSE_TOP="close-top",he.CLASS_CLOSE_BOTTOM="close-bottom",he.CLASS_DRAG="drag",he.DEFAULT_WIDTH=245,he.TEXT_CLOSED="Close Controls",he.TEXT_OPEN="Open Controls",he._keydownHandler=function(e){"text"===document.activeElement.type||72!==e.which&&72!==e.keyCode||he.toggleHide()},X.bind(window,"keydown",he._keydownHandler,!1),S.extend(he.prototype,{add:function(e,t){return f(this,e,t,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(e,t){return f(this,e,t,{color:!0})},remove:function(e){this.__ul.removeChild(e.__li),this.__controllers.splice(this.__controllers.indexOf(e),1);var t=this;S.defer(function(){t.onResize()})},destroy:function(){if(this.parent)throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");this.autoPlace&&ce.removeChild(this.domElement);var e=this;S.each(this.__folders,function(t){e.removeFolder(t)}),X.unbind(window,"keydown",he._keydownHandler,!1),u(this)},addFolder:function(e){if(void 0!==this.__folders[e])throw new Error('You already have a folder in this GUI by the name "'+e+'"');var t={name:e,parent:this};t.autoPlace=this.autoPlace,this.load&&this.load.folders&&this.load.folders[e]&&(t.closed=this.load.folders[e].closed,t.load=this.load.folders[e]);var n=new he(t);this.__folders[e]=n;var o=c(this,n.domElement);return X.addClass(o,"folder"),n},removeFolder:function(e){this.__ul.removeChild(e.domElement.parentElement),delete this.__folders[e.name],this.load&&this.load.folders&&this.load.folders[e.name]&&delete this.load.folders[e.name],u(e);var t=this;S.each(e.__folders,function(t){e.removeFolder(t)}),S.defer(function(){t.onResize()})},open:function(){this.closed=!1},close:function(){this.closed=!0},hide:function(){this.domElement.style.display="none"},show:function(){this.domElement.style.display=""},onResize:function(){var e=this.getRoot();if(e.scrollable){var t=X.getOffset(e.__ul).top,n=0;S.each(e.__ul.childNodes,function(t){e.autoPlace&&t===e.__save_row||(n+=X.getHeight(t))}),window.innerHeight-t-20<n?(X.addClass(e.domElement,he.CLASS_TOO_TALL),e.__ul.style.height=window.innerHeight-t-20+"px"):(X.removeClass(e.domElement,he.CLASS_TOO_TALL),e.__ul.style.height="auto")}e.__resize_handle&&S.defer(function(){e.__resize_handle.style.height=e.__ul.offsetHeight+"px"}),e.__closeButton&&(e.__closeButton.style.width=e.width+"px")},onResizeDebounced:S.debounce(function(){this.onResize()},50),remember:function(){if(S.isUndefined(le)&&((le=new ie).domElement.innerHTML='<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'),this.parent)throw new Error("You can only call remember on a top level GUI.");var e=this;S.each(Array.prototype.slice.call(arguments),function(t){0===e.__rememberedObjects.length&&v(e),-1===e.__rememberedObjects.indexOf(t)&&e.__rememberedObjects.push(t)}),this.autoPlace&&w(this,this.width)},getRoot:function(){for(var e=this;e.parent;)e=e.parent;return e},getSaveObject:function(){var e=this.load;return e.closed=this.closed,this.__rememberedObjects.length>0&&(e.preset=this.preset,e.remembered||(e.remembered={}),e.remembered[this.preset]=x(this)),e.folders={},S.each(this.__folders,function(t,n){e.folders[n]=t.getSaveObject()}),e},save:function(){this.load.remembered||(this.load.remembered={}),this.load.remembered[this.preset]=x(this),_(this,!1),this.saveToLocalStorageIfPossible()},saveAs:function(e){this.load.remembered||(this.load.remembered={},this.load.remembered[se]=x(this,!0)),this.load.remembered[e]=x(this),this.preset=e,g(this,e,!0),this.saveToLocalStorageIfPossible()},revert:function(e){S.each(this.__controllers,function(t){this.getRoot().load.remembered?p(e||this.getRoot(),t):t.setValue(t.initialValue),t.__onFinishChange&&t.__onFinishChange.call(t,t.getValue())},this),S.each(this.__folders,function(e){e.revert(e)}),e||_(this.getRoot(),!1)},listen:function(e){var t=0===this.__listening.length;this.__listening.push(e),t&&C(this.__listening)},updateDisplay:function(){S.each(this.__controllers,function(e){e.updateDisplay()}),S.each(this.__folders,function(e){e.updateDisplay()})}});var pe={Color:I,math:N,interpret:R},fe={Controller:z,BooleanController:K,OptionController:Y,StringController:J,NumberController:W,NumberControllerBox:Q,NumberControllerSlider:q,FunctionController:Z,ColorController:$},me={dom:X},ge={GUI:he},be=he,ve={color:pe,controllers:fe,dom:me,gui:ge,GUI:be};e.color=pe,e.controllers=fe,e.dom=me,e.gui=ge,e.GUI=be,e.default=ve,Object.defineProperty(e,"__esModule",{value:!0})});
        </script>

   <!--    <button class="openPort">Open Serial Port</button> 
             <button class="Audio">Play: audio.mp3</button> 

        <button id="button1">PLAY 1</button>
        <button id="button2">PLAY 2</button>          -->
          
    </head>
    
    <canvas id = "canvas"></canvas>
       
    <body>
       
<!-- <script src="./script.js"></script> -->
     
<script type="text/javascript"  defer="defer">
            'use strict';     // ********************** ALL JavaScript code frpm here to END  ****************************
 
 
const canvas = document.getElementsByTagName('canvas')[0];
canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;

let bkimage = new Image();
    bkimage.onload = () => {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, bkimage);
        //gl.drawImage(bkimage, 0, 0);
        canvas.style.backgroundImage = "url('" + bkimage.src + "')";

        console.log('bkimage loaded', bkimage,canvas.style );
    };  
bkimage.src = './images/background_image1.png';
     
canvas.style.background_image = true;
canvas.style.backgroundSize = "100%" ;
canvas.style.backgroundPositionX = "0.0";
canvas.style.backgroundPositionY = "0.0";
console.log('LOAD BKGND',canvas.style);

Array.prototype.getRandom = function() {
    return this[Math.floor(Math.random() * this.length)];
};  
 

// Set up audio context
/*
const BTN1=document.getElementById('button1'); 
const BTN2=document.getElementById('button2');
const container1 = document.getElementById('container1');
//const canvas1 = document.getElementById('canvas1');
let audio1 = new Audio();
audio1.src='http://localhost:8000/bells1.wav';
let audio2 = new Audio();
audio2.src='http://localhost:8000/audio.mp3';



if (BTN1){
    BTN1.addEventListener('click', function() { 
        console.log('BTN1 click - audio1.play', BTN1);
        audio1.play();
        audio1.addEventListener('playing', function() {
            console.log('audio1 playing');
            BTN1.Name = 'PAUSE 1';
        } )
        const audioCtx = new AudioContext();
        console.log('BTN1 audio', audioCtx);
 
    } ) ;
}
else{ console.log('BTN1 not found' , BTN1 )} 


if (BTN2){
    BTN2.addEventListener('click', function() { 
        console.log('BTN2 click - audio2.play');
        audio2.play();
        audio2.addEventListener('playing', function() {
            console.log('audio2 playing');
            
        } )
        const audioCtx2 = new AudioContext();
        console.log('BTN2 audio', audioCtx2);
    } ) ;
}
else{ console.log('BTN2 not found' , BTN2 )} 

*/
/*
// get audio media element for FFT - mic
navigator.getUserMedia = navigator.getUserMedia
                                   || navigator.webkitGetUserMedia
                                   || navigator.mozGetUserMedia;

navigator.getUserMedia({ video : false, audio : true }, callback, console.log);

var analyser;
var data;
let bufferLength=0;
var AudioDataArray = null;

function callback(stream) {   
    var Actx = new AudioContext();
    var mic = Actx.createMediaStreamSource(stream);
    analyser = Actx.createAnalyser();
    mic.connect(analyser); 
    InitFFT();
    //  analyser.getByteFrequencyData(AudioDataArray);    // now call data repeatedly with this cmd
    //  console.log("data:", bufferLength, AudioDataArray);
    
  }   // !callback
 

  function InitFFT() {
    analyser.fftSize = config.FREQ_RANGE  ;
    bufferLength = analyser.frequencyBinCount;            // half of fft size = number of data bins
    AudioDataArray = new Uint8Array(bufferLength);
    }
 
   //myFFT = setInterval(AudioFreqLoop,64);  // loops commands = mSeconds


   function AudioFreqLoop()  {     // FFT analysis from Microphone Input

if(typeof analyser === 'undefined')  {}
else if (config.AUDIO_RESPONSIVE) {
//    else {
 analyser.getByteFrequencyData(AudioDataArray);
console.log("data:", bufferLength, AudioDataArray);
 // console.log('AudioAnalyse ',U++);

// config.DELTAMULT = AudioDataArray[0];
// config.OSC_DIAMETER = AudioDataArray[2];

const color = config.COLORFUL ? generateColor() : Object.assign({}, config.POINTER_COLOR.getRandom());
RADIUS = config.OSC_RADIUS; 
let thresh = config.OSC_DIAMETER-30 ;     
let divide = config.SOUND_SENSITIVITY*config.DELTASIZE/4;  
// console.log("AUDIO Freq Loop:", AudioDataArray[2]);
let segments = (bufferLength-config.FREQ_RANGE_START)*config.FREQ_RANGE_Percent ;  

for (let x = config.FREQ_RANGE_START; x<segments; x++)  {
         //   SL_24_Patterns(21,x);  // call 24 times per q note
           let X = 50+canvas.width*1/(segments+2)*(x+1);
            let H = -(AudioDataArray[x]-thresh)/divide;
            let Y = canvas.height*10/12 + H ;
         
        if (AudioDataArray[x]> thresh)  { 
            if( PPQcnt==1)  { 
                splat(X,Y,0,H,color);
              //  splat(X,Y,0,H,color);
              //  blob(X,Y,0,H,color);
             }
            console.log("AUDIO:", x,H);
            }
        else  {   
          //  splat(X,Y,0,1,color)
            }
        }  
        */     
/*  config.DELTASIZE = AudioDataArray[1];
config.OSC_DIAMETER = AudioDataArray[2];
config.SPLAT_RADIUS = AudioDataArray[3];
config.OSC_RADIUS = AudioDataArray[4];

config.mvel = AudioDataArray[5];
config.oscVel = AudioDataArray[6];
config.LFO_CX1 = AudioDataArray[7];
config.CX1offset = AudioDataArray[8];
config.CY1offset = AudioDataArray[9];

config.sdt = AudioDataArray[10];
config.VELOCITY_DISSIPATION = AudioDataArray[11];
config.DENSITY_DISSIPATION = AudioDataArray[12];
config.PRESSURE_DISSIPATION = AudioDataArray[13]; 
config.CURL = AudioDataArray[15];
config.LFO_BPM = AudioDataArray[14];
config.TIME = AudioDataArray[15]; 
config.LFO_CY1 = AudioDataArray[0];
config.LFO_CX2 = AudioDataArray[1];
config.LFO_CY2 = AudioDataArray[2];
config.LFO_AMPL1 = AudioDataArray[3];
config.LFO_AMPL2 = AudioDataArray[4];
config.LFO_AMPL3 = AudioDataArray[5];
config.LFO_AMPL4 = AudioDataArray[6];    */

 // ! AudioFreqLoop()






let splatColors = [{ r: 0, g: 0.15, b: 0 }];

let config = {
    SIM_RESOLUTION: 256,
    DYE_RESOLUTION: 1024,
    DENSITY_DISSIPATION: 0.98,     //.97
    VELOCITY_DISSIPATION: 0.98,    //.97
    PRESSURE_DISSIPATION: 0.07,   //0.8
    PRESSURE_ITERATIONS: 20,
    CURL: 0,			//30
    SPLAT_RADIUS: 0.15,     //.3
    OSC_RADIUS: 0.05,     //.3
    SHADING: true,
    COLORFUL: true,
    BACK_COLOR: { r: 25, g: 0, b: 35},
    TRANSPARENT: false,
    BLOOM: false,
    BLOOM_ITERATIONS: 8,
    BLOOM_RESOLUTION: 256,
    BLOOM_INTENSITY: 0.3,       //0.8
    BLOOM_THRESHOLD: 0.6,
    BLOOM_SOFT_KNEE: 0.7,
    POINTER_COLOR: [{ r: 0.0, g: 0.0, b: 0.72}],
    SOUND_SENSITIVITY: 0.25,
    AUDIO_RESPONSIVE: true,
    FREQ_RANGE: 32,
    FREQ_RANGE_START: 0,
    FREQ_RANGE_Percent: 1.0,  // multiplier
    
    sdt: 0.405,         //frame time
    TIME: 120,          //bpm
    speed: 20,          //osc cnt size
   
    LFO_BPM: 10,        // 0.5-120
    OSC_DIAMETER: 30,   // 1-127
    DELTASIZE: 30,
    DELTAMULT: 32,
    mvel: 40,
    oscVel: 40,
    LFO_AMPLC: 30,
    LFO_AMPL1: 30,
    LFO_AMPL2: 30,
    LFO_AMPL3: 40,
    LFO_AMPL4: 60,
    LFO_EN: true,
    LFO_Colorthrob: false,
    LFO_mvel: false,
    LFO_oscVel: false,
    LFO_oscDiam: false,
    LFO_PHASE_Flag: false,
    LFO_CX1_flag: false,
    LFO_CY1_flag: false,
    LFO_CX2_flag: false,
    LFO_CY2_flag: false,
    LFO_CX1: 0,
    LFO_CY1: 0,
    LFO_CX2: 0,
    LFO_CY2: 0,
    MIDI_mvel: false,
    MIDI_oscVel: false,
    MIDI_oscDiam: false,
   BKColorChangeFLAG: false,

   PAUSED: false,
   DemoSequence_Flag: false, // enables counter at end of SequenceLoop - to seq demos
    OSC_DEMO_FLAG: true,    // Sequence Loop  ON/OFF FOR OSC_DEMO 1-20
    RUN_FLAG: true,         // SequenceLoop-BPM  ON/OFF FOR K DEMO 1-10 
    DEMO_Index: 1,          // 1-16 = K DEMOS
    OSC_DEMO: 19            // 0 OFF 1-20 = LINE OSC DEMOS
};

console.log('config:', config);
console.log('canvas:', canvas);
 
// Load() ;
  
 
function indexOfMax(arr) {
    if (arr.length === 0) {
        return -1;
    }

    var max = arr[0];
    var maxIndex = 0;

    for (var i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            maxIndex = i;
            max = arr[i];
        }
    }

    return maxIndex;
}

function pointerPrototype () {
    this.id = -1;
    this.x = 0;
    this.y = 0;
    this.dx = 0;
    this.dy = 0;
    this.down = false;
    this.moved = false;
    this.color = [30, 0, 300];
}
let angle=0;
let pointers = [];
let splatStack = [];
let bloomFramebuffers = [];
pointers.push(new pointerPrototype());

const { gl, ext } = getWebGLContext(canvas);

if (isMobile())
    config.SHADING = false;
if (!ext.supportLinearFiltering)
{
    config.SHADING = false;
    config.BLOOM = false;
}

 
//globals - CDA
let DR = 1;
let DB = 1;
let Pdx = 100 ;
let Pdy = 100 ;
let PPQ = 1;
let PPQcnt = 1;
let PPQX = 1;
let PPQY = 1;
let PPQX_DIR = true;
let PPQY_DIR = true;
let myBPM = 0;
let myLFO = 0;
let myFFT = 0;
let LFO_Value = 60;  
let LFO_DIR = true; 
let LFO_PHASE = -1;       //-1
const AltFlag = [];
for (DR=0;DR<8;DR++) {
    AltFlag[DR] = false;
}
DR = 1;
let RADIUS = config.SPLAT_RADIUS; 
let OSC_DIA_min = 20;
let OSC_mvel_min = config.mvel;    
let OSC_oscVel_min = config.oscVel;    
let SLcount = 0;
let Kpattern = 11;
let CX1offset = 0;
let CY1offset = 0;
let CX2offset = 0;
let CY2offset = 0;

connect();       // MIDI
clearInterval(myLFO);
myLFO = setInterval(LFO_Loop,1000/config.LFO_BPM);  // loops LFO: 0.5 - 120 BPM
clearInterval(myBPM);
myBPM = setInterval(SequenceLoop,2500/config.TIME);  // loops commands = mSeconds


if (!isMobile())  {  
    var gui = new dat.GUI({ width: 300 , background_color: 100 });
    startGUI();  }



    function save() {
        // Prepare data for API
        const payload = {
            name: "Data_AOM_Config_" + Date.now(),
            type: "AOM",
            data: config
        };

        fetch('api_v2.php?action=save_preset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Preset saved to Server DB with ID:', data.id);
                alert('Saved to Server!');
            } else {
                console.error('Save failed:', data.error);
                alert('Save Failed: ' + data.error);
            }
        })
        .catch(err => console.error('Error saving:', err));
    }
    
    // Global Preset List for cycling
    let presetList = [];
    let presetIndex = 0;

    function Load()  {
         // Fetch latest presets from DB
         fetch('api_v2.php?action=get_presets&type=AOM')
            .then(res => res.json())
            .then(data => {
                if (!data || data.length === 0) {
                    console.log("No presets found in DB.");
                    return;
                }
                
                presetList = data;
                
                // Cycle index
                presetIndex++;
                if (presetIndex >= presetList.length) presetIndex = 0;
                
                const selectedPreset = presetList[presetIndex];
                console.log("Loading Preset from DB:", selectedPreset.name);
                
                // Parse 'data' column (it might be a string from the DB)
                let configData = selectedPreset.data;
                if (typeof configData === 'string') {
                    try { configData = JSON.parse(configData); } catch(e) { console.error("JSON Parse Error", e); }
                }
                
                config = { ...configData }; // Merge
                console.log('New CONFIG applied');
                if (window.gui) window.gui.updateDisplay();
                
            })
            .catch(err => console.error("Error loading presets:", err));
    } // ! Load

// --- ADDED BY GEMINI ---
function LoadURL(url) {
    // Legacy support for direct file loading, or could be used if API returns a URL
    // But for DB, we usually load data directly. 
    // If 'url' is passed, we assume it's a file path.
    console.log("Loading Config from URL:", url);
    fetch(url)
        .then(res => res.json())
        .then(res => {
            config = { ...res };
            console.log('new CONFIG loaded:', config);
            if (window.gui) window.gui.updateDisplay();
        })
        .catch(err => console.error("Error loading config:", err));
}
window.LoadURL = LoadURL;

// Check for config parameter in URL (Search or Hash)
function getConfigParam() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('config')) return urlParams.get('config');
    
    // Check hash
    if (window.location.hash.includes('config=')) {
        const hash = window.location.hash.substring(1); // remove #
        const hashParams = new URLSearchParams(hash);
        return hashParams.get('config');
    }
    return null;
}

const configParam = getConfigParam();
if (configParam) {
    let loadPath = configParam;
    if (!loadPath.includes('/')) {
        loadPath = './presets/' + loadPath;
    }
    // Delay slightly to ensure gui/config are ready
    setTimeout(() => LoadURL(loadPath), 500);
}

// -----------------------



function getWebGLContext (canvas) {
    const params = { alpha: true, depth: false, stencil: false, antialias: false, preserveDrawingBuffer: false };

    let gl = canvas.getContext('webgl2', params);
    const isWebGL2 = !!gl;
    if (!isWebGL2)
        gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);

    let halfFloat;
    let supportLinearFiltering;
    if (isWebGL2) {
        gl.getExtension('EXT_color_buffer_float');
        supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
    } else {
        halfFloat = gl.getExtension('OES_texture_half_float');
        supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
    }

    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;
    let formatRGBA;
    let formatRG;
    let formatR;

    if (isWebGL2)
    {
        console.log('MSG: isWebGL2 IS TRUE   ');
        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
    }
    else
    {
        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
    }

    return {
        gl,
        ext: {
            formatRGBA,
            formatRG,
            formatR,
            halfFloatTexType,
            supportLinearFiltering
        }
    };
}

function getSupportedFormat (gl, internalFormat, format, type)
{
    if (!supportRenderTextureFormat(gl, internalFormat, format, type))
    {
        switch (internalFormat)
        {
            case gl.R16F:
                return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
            case gl.RG16F:
                return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
            default:
                return null;
        }
    }

    return {
        internalFormat,
        format
    }
}

function supportRenderTextureFormat (gl, internalFormat, format, type) {
    let texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);

    let fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status != gl.FRAMEBUFFER_COMPLETE)
        return false;
    return true;
}

function LFO_Loop() {
    let dd = 0;
    if(config.LFO_EN && LFO_DIR===true && LFO_Value<60)  LFO_Value=LFO_Value+1;
    if(config.LFO_EN && LFO_DIR===false && LFO_Value>0)  LFO_Value=LFO_Value-1;
    if(LFO_Value>=60) { LFO_DIR=false;  }
    if(LFO_Value<1) LFO_DIR=true;
  
    if (LFO_Value === 60 || LFO_Value === 0) {
        console.log('LFO TRIG:'  , LFO_Value); 
        }
        
    else {      // slow changing LFO_Value 1-60
       // console.log('LFO:' , LFO_Value  );
       if (config.LFO_Colorthrob) { 
            config.BACK_COLOR.r  = -10 + config.LFO_AMPLC*LFO_Value/10 ;
            config.BACK_COLOR.g  = -150 + config.LFO_AMPLC*LFO_Value/10 ;
            config.BACK_COLOR.b  = -1 + config.LFO_AMPLC*LFO_Value/10 ;
            if(config.BACK_COLOR.r>255)  config.BACK_COLOR.r=255;
            if(config.BACK_COLOR.g>255)  config.BACK_COLOR.g=255;
            if(config.BACK_COLOR.b>255)  config.BACK_COLOR.b=255;
            if(config.BACK_COLOR.r<0)  config.BACK_COLOR.r=0;
            if(config.BACK_COLOR.g<0)  config.BACK_COLOR.g=0;
            if(config.BACK_COLOR.b<0)  config.BACK_COLOR.b=0;
            
          //  console.log('color:' ,config.LFO_AMPL*LFO_Value/10, config.BACK_COLOR.r,config.BACK_COLOR.g,config.BACK_COLOR.b);
            }
        if (config.LFO_mvel) {
            config.mvel = OSC_mvel_min + (config.LFO_AMPL1/8) * LFO_Value ;
            gui.updateDisplay();
            }
        if (config.LFO_oscVel) {
            dd = (config.LFO_AMPL2/8) * LFO_Value;
            if(config.LFO_PHASE_Flag)  { dd = 128 - (config.LFO_AMPL2/8) * LFO_Value; } 
            config.oscVel = OSC_oscVel_min + dd;
            gui.updateDisplay();
            }    
        if (config.LFO_oscDiam) {
            dd = (config.LFO_AMPL3/32) * LFO_Value;
            config.OSC_DIAMETER = OSC_DIA_min + dd ;
            gui.updateDisplay();
            }
            config.LFO_CX1 = CX1offset ;
            config.LFO_CY1 = CY1offset ;
            config.LFO_CX2 = CX2offset ;
            config.LFO_CY2 = CY2offset ;
             
        if (config.LFO_CX1_flag) {
            let dd = (60-2*LFO_Value)*config.LFO_AMPL4/32 + CX1offset;
            config.LFO_CX1 = dd ;
            gui.updateDisplay();
            }  
        
        if (config.LFO_CX2_flag) {
            let dd = (60*config.LFO_AMPL4/32)-(config.LFO_AMPL4/16) * LFO_Value + CX2offset;
           config.LFO_CX1 = dd ;
            config.LFO_CX2 = -dd ;
            gui.updateDisplay();
            }
        if (config.LFO_CY1_flag) {
            let dd = (60*config.LFO_AMPL4/32)-(config.LFO_AMPL4/16) * LFO_Value + CY1offset;
            config.LFO_CY1 = dd ;
           // config.LFO_CX2 = -dd ;
            gui.updateDisplay();  
            }     
        if (config.LFO_CY2_flag) {
            let dd = (60*config.LFO_AMPL4/32)-(config.LFO_AMPL4/16) * LFO_Value + CY2offset;
            config.LFO_CY1 = dd ;
            config.LFO_CY2 = -dd ;
            gui.updateDisplay();  
            }    
        }  // !else
    }  // ! LFO LOOP

function ReversePhase() {
    if(config.LFO_PHASE_Flag)  { LFO_PHASE = 1; }
    else  { LFO_PHASE = -1; }
    UpdateAPC20_MIDI;   
    }    
function resetLFO() {
    clearInterval(myLFO);
    myLFO = setInterval(LFO_Loop,1000/config.LFO_BPM)  // loops LFO: 0.5 - 120 BPM
    }
function resetInterval() {
    clearInterval(myBPM)
    myBPM = setInterval(SequenceLoop,2500/config.TIME)  // loops commands = mSeconds
    }      // 700
    
function resetDIA() {
    if(!config.LFO_oscDiam)  OSC_DIA_min = config.OSC_DIAMETER; 
    UpdateAPC20_MIDI;      
    }   

function UpdateCX1() {
    CX1offset=config.LFO_CX1;       
    }  
function UpdateCX2() {
    CX2offset=config.LFO_CX2;       
    }  
function UpdateCY1() {
    CY1offset=config.LFO_CY1;       
    }  
function UpdateCY2() {
    CY2offset=config.LFO_CY2;       
    }  
function startGUI () {
   // var gui = new dat.GUI({ width: 300 , background_color: 100 });
    //   gui.add(config, 'SIM_RESOLUTION', { '32': 32, '64': 64, '128': 128, '256': 256 }).name('sim resolution').onFinishChange(initFramebuffers);
  //  gui.add(config, 'DYE_RESOLUTION', { '128': 128, '256': 256, '5'-'12': 512, '1024': 1024 }).name('dye resolution').onFinishChange(initFramebuffers);
    gui.add(config, 'sdt', 0.001, 2.060).name('Step TIme r/f').step(0.001);  //0.009
    gui.add(config, 'VELOCITY_DISSIPATION', 0.8, 1.01).name('velocity diffusion t/g').step(0.001);
    gui.add(config, 'DENSITY_DISSIPATION', 0.8, 1.01).name('density diffusion y/h').step(0.001);
    gui.add(config, 'PRESSURE_DISSIPATION', 0.0, 1.0).name('pressure diffusion u/j').step(0.01);
    gui.add(config, 'CURL', 0, 10).name('vorticity-curl i/k').step(0.1);
    gui.add(config, 'SPLAT_RADIUS', 0.01, 1.0).name('splat radius o/l').step(0.01);
    gui.add(config, 'mvel', 0, 127).name('MIDI Velocity').step(1);         //50  
    gui.add(config, 'OSC_RADIUS', 0.01, 1.0).name('OSC radius').step(.01);
    
    gui.add(config, 'RUN_FLAG').name('K-RUN 1-of-16 demos').onChange(UpdateAPC20_MIDI);
    gui.add(config, 'DEMO_Index',1,24).name('Current K Demo=').step(1).listen().onChange(KeyHandler('K'));
    gui.add(config, 'OSC_DEMO',1,23).name('Current OSC_DEMO=').step(1).listen().onChange(KeyHandler('-'));
 // gui.add({ fun: () => { KeyHandler('K'); } }, 'fun').name('Next K Demo'); 
    gui.add(config, 'LFO_BPM', 0.5, 100).name('LFO BPM').step(0.5).onChange(resetLFO); 
    gui.add(config, 'TIME', 20, 300).name('BPM O/L').step(1).onChange(resetInterval); 
    gui.add(config, 'OSC_DEMO_FLAG').name('OSC_DEMO - 1-of-20 demos').onChange(UpdateAPC20_MIDI);
  //    gui.add(config, 'OSC_DEMO').name('NEXT OSC_DEMO =').listen().onChange(KeyHandler('-'));
//    gui.add({ fun: () => { KeyHandler('-'); } }, 'fun').name('Next OSC Demo'); ///   gui.add(OSC_DEMO).name('osc Demo #'); 
   gui.add(config, 'OSC_DIAMETER', 0, 250).name('OSC Diameter').step(1).onChange(resetDIA);         //10  
   gui.add(config, 'DELTASIZE', 1, 200).name('OSC Size').step(1);         //50  
   gui.add(config, 'DELTAMULT', 1, 128).name('OSC Mult').step(1);         //20  
    gui.add(config, 'oscVel', 0, 420).name('OSC Vel').step(1);         //50  
    gui.add(config, 'DemoSequence_Flag').name('Run Demo Sequence').listen().onChange(UpdateAPC20_MIDI) ;  
    gui.add(config, 'LFO_PHASE_Flag').name('REVERSE').listen().onChange(ReversePhase);   
     //  gui.BACK_COLOR = {r: 25,g: 70,b: 158};
// gui.addColor(config, 'BACK_COLOR').name('background color');
 
gui.add(config, 'LFO_CX1', -500, 500).name('Delta CX1').step(1).onChange(UpdateCX1);    // 0  
gui.add(config, 'LFO_CY1', -500, 500).name('Delta CY1').step(1).onChange(UpdateCY1);     // 0  
gui.add(config, 'LFO_CX2', -500, 500).name('Delta CX2').step(1).onChange(UpdateCX2);     // 0  
gui.add(config, 'LFO_CY2', -500, 500).name('Delta CY2').step(1).onChange(UpdateCY2);     // 0  
gui.add(config, 'speed', 1, 64).name('OscCount for Demos 1-12  P/:').step(1);         //10  
    
let LFOFolder = gui.addFolder('LFO Controls');
 LFOFolder.add(config, 'LFO_AMPL1', 1, 128).name('LFO AMPL1 mVel').step(1);      //1  
 LFOFolder.add(config, 'LFO_AMPL2', 1, 128).name('LFO AMPL2 oscVel').step(1);      //1  
 LFOFolder.add(config, 'LFO_AMPL3', 1, 128).name('LFO AMPL3 oscDia').step(1);      //1  
 LFOFolder.add(config, 'LFO_AMPL4', 1, 128).name('LFO AMPL4 oscSize').step(1);      //1  
 
LFOFolder.add(config, 'LFO_EN').name('LFO Enable').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_Colorthrob').name('LFO BKColor Cycle').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_mvel').name('LFO MIDI Vel mvel').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_oscVel').name('LFO OSC Vel oscVel').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_oscDiam').name('LFO OSC Diameter').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_CX1_flag').name('LFO Center X1').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_CY1_flag').name('LFO Center Y1').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_CX2_flag').name('LFO Center X2').listen().onChange(UpdateAPC20_MIDI);  
LFOFolder.add(config, 'LFO_CY2_flag').name('LFO Center Y2').listen().onChange(UpdateAPC20_MIDI);  
   
   //  gui.add(config, 'PAUSED').name('paused  space').listen();
  /*  gui.add({ fun: () => {
        splatStack.push(parseInt(Math.random() * 20) + 5);
    } }, 'fun').name('Random splats: 1-9 0 z x c v b n m');   */
    let bloomFolder = gui.addFolder('Bloom and Shading and Audio');
    bloomFolder.add(config, 'BLOOM').name('BLOOM enabled');
    bloomFolder.add(config, 'BLOOM_INTENSITY', 0.1, 2.0).name('intensity');
    bloomFolder.add(config, 'BLOOM_THRESHOLD', 0.0, 1.0).name('threshold');
    bloomFolder.add(config, 'SHADING').name('shading Enabled');
    bloomFolder.add(config, 'COLORFUL').name('colorful');
    bloomFolder.add(config, 'TRANSPARENT').name('transparent');
  //  bloomFolder.add(config, 'AUDIO_RESPONSIVE').name('Audio FFT Enable');
  //  bloomFolder.add(config, 'SOUND_SENSITIVITY', 0.01, 1.0).name('Audio Gain');
  //  bloomFolder.add(config, 'FREQ_RANGE', 32, 256).name('FFT size').onChange(InitFFT);
  //  bloomFolder.add(config, 'FREQ_RANGE_START', 0, 32).name('FFT Start');
  //  bloomFolder.add(config, 'FREQ_RANGE_Percent', 0.0, 1.0).name('FFT %');

  //  gui.add({ fun: captureScreenshot }, 'fun').name('take screenshot');

   // let app = gui.add({ fun : () => {
   //     window.open('http://onelink.to/5b58bn');
   // } }, 'fun').name('Check out new improved version');
   // app.__li.className = 'cr function appBigFont';
   // app.__li.style.borderLeft = '3px solid #00FF7F';
   // let appIcon = document.createElement('span');
   // app.domElement.parentElement.appendChild(appIcon);
   // appIcon.className = 'icon app';

  //  if (isMobile())
        gui.close();
}  // !startgui

//*******************************************************
let simWidth=100;
let simHeight=100;
let dyeWidth;
let dyeHeight;
let density;
let velocity;
let divergence;
let curl;
let pressure;
let bloom;


//*******************************************************


function captureScreenshot () {
    colorProgram.bind();
    gl.uniform4f(colorProgram.uniforms.color, 0, 0, 0, 1);
    blit(density.write.fbo);

    render(density.write.fbo);
    gl.bindFramebuffer(gl.FRAMEBUFFER, density.write.fbo);

    let length = dyeWidth * dyeHeight * 4;
    let pixels = new Float32Array(length);
    gl.readPixels(0, 0, dyeWidth, dyeHeight, gl.RGBA, gl.FLOAT, pixels);

    let newPixels = new Uint8Array(length);

    let id = 0;
    for (let i = dyeHeight - 1; i >= 0; i--) {
        for (let j = 0; j < dyeWidth; j++) {
            let nid = i * dyeWidth * 4 + j * 4;
            newPixels[nid + 0] = clamp01(pixels[id + 0]) * 255;
            newPixels[nid + 1] = clamp01(pixels[id + 1]) * 255;
            newPixels[nid + 2] = clamp01(pixels[id + 2]) * 255;
            newPixels[nid + 3] = clamp01(pixels[id + 3]) * 255;
            id += 4;
        }
    }

    let captureCanvas = document.createElement('canvas');
    let ctx = captureCanvas.getContext('2d');
    captureCanvas.width = dyeWidth;
    captureCanvas.height = dyeHeight;

    let imageData = ctx.createImageData(dyeWidth, dyeHeight);
    imageData.data.set(newPixels);
    ctx.putImageData(imageData, 0, 0);
    
     let datauri = captureCanvas.toDataURL();
     downloadURI("..\Image_AOM_Preview.png", datauri);
     URL.revokeObjectURL(datauri);
}  //  ! CaptureScreenShot()

function clamp01 (input) {
    return Math.min(Math.max(input, 0), 1);
}

function downloadURI (filename, uri) {          // saves preview file
    let link = document.createElement("a");
    link.download = filename;
    link.href = uri;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}



function isMobile () {
    return /Mobi|Android/i.test(navigator.userAgent);
}

class GLProgram {
    constructor (vertexShader, fragmentShader) {
        this.uniforms = {};
        this.program = gl.createProgram();

        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))
            throw gl.getProgramInfoLog(this.program);

        const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < uniformCount; i++) {
            const uniformName = gl.getActiveUniform(this.program, i).name;
            this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);
        }
    }

    bind () {
        gl.useProgram(this.program);
    }
}

function compileShader (type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        throw gl.getShaderInfoLog(shader);

    return shader;
};

const baseVertexShader = compileShader(gl.VERTEX_SHADER, `
    precision highp float;

    attribute vec2 aPosition;
    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform vec2 texelSize;

    void main () {
        vUv = aPosition * 0.5 + 0.5;
        vL = vUv - vec2(texelSize.x, 0.0);
        vR = vUv + vec2(texelSize.x, 0.0);
        vT = vUv + vec2(0.0, texelSize.y);
        vB = vUv - vec2(0.0, texelSize.y);
        gl_Position = vec4(aPosition, 0.0, 1.0);
    }
`);

const clearShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying highp vec2 vUv;
    uniform sampler2D uTexture;
    uniform float value;

    void main () {
        gl_FragColor = value * texture2D(uTexture, vUv);
    }
`);

const colorShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;

    uniform vec4 color;

    void main () {
        gl_FragColor = color;
    }
`);

const backgroundShader = compileShader(gl.FRAGMENT_SHADER, `
    void main () {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }
`);

const displayShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    uniform sampler2D uTexture;

    void main () {
        vec3 C = texture2D(uTexture, vUv).rgb;
        float a = max(C.r, max(C.g, C.b));
        gl_FragColor = vec4(C, a);
    }
`);

const displayBloomShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform sampler2D uBloom;
    uniform sampler2D uDithering;
    uniform vec2 ditherScale;

    void main () {
        vec3 C = texture2D(uTexture, vUv).rgb;
        vec3 bloom = texture2D(uBloom, vUv).rgb;
        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;
        noise = noise * 2.0 - 1.0;
        bloom += noise / 800.0;
        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));
        C += bloom;
        float a = max(C.r, max(C.g, C.b));
        gl_FragColor = vec4(C, a);
    }
`);

const displayShadingShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uTexture;
    uniform vec2 texelSize;

    void main () {
        vec3 L = texture2D(uTexture, vL).rgb;
        vec3 R = texture2D(uTexture, vR).rgb;
        vec3 T = texture2D(uTexture, vT).rgb;
        vec3 B = texture2D(uTexture, vB).rgb;
        vec3 C = texture2D(uTexture, vUv).rgb;

        float dx = length(R) - length(L);
        float dy = length(T) - length(B);

        vec3 n = normalize(vec3(dx, dy, length(texelSize)));
        vec3 l = vec3(0.0, 0.0, 1.0);

        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
        C.rgb *= diffuse;

        float a = max(C.r, max(C.g, C.b));
        gl_FragColor = vec4(C, a);
    }
`);

const displayBloomShadingShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uTexture;
    uniform sampler2D uBloom;
    uniform sampler2D uDithering;
    uniform vec2 ditherScale;
    uniform vec2 texelSize;

    void main () {
        vec3 L = texture2D(uTexture, vL).rgb;
        vec3 R = texture2D(uTexture, vR).rgb;
        vec3 T = texture2D(uTexture, vT).rgb;
        vec3 B = texture2D(uTexture, vB).rgb;
        vec3 C = texture2D(uTexture, vUv).rgb;

        float dx = length(R) - length(L);
        float dy = length(T) - length(B);

        vec3 n = normalize(vec3(dx, dy, length(texelSize)));
        vec3 l = vec3(0.0, 0.0, 1.0);

        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
        C *= diffuse;

        vec3 bloom = texture2D(uBloom, vUv).rgb;
        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;
        noise = noise * 2.0 - 1.0;
        bloom += noise / 800.0;
        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));
        C += bloom;

        float a = max(C.r, max(C.g, C.b));
        gl_FragColor = vec4(C, a);
    }
`);

const bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying vec2 vUv;
    uniform sampler2D uTexture;
    uniform vec3 curve;
    uniform float threshold;

    void main () {
        vec3 c = texture2D(uTexture, vUv).rgb;
        float br = max(c.r, max(c.g, c.b));
        float rq = clamp(br - curve.x, 0.0, curve.y);
        rq = curve.z * rq * rq;
        c *= max(rq, br - threshold) / max(br, 0.0001);
        gl_FragColor = vec4(c, 0.0);
    }
`);

const bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uTexture;

    void main () {
        vec4 sum = vec4(0.0);
        sum += texture2D(uTexture, vL);
        sum += texture2D(uTexture, vR);
        sum += texture2D(uTexture, vT);
        sum += texture2D(uTexture, vB);
        sum *= 0.25;
        gl_FragColor = sum;
    }
`);

const bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uTexture;
    uniform float intensity;

    void main () {
        vec4 sum = vec4(0.0);
        sum += texture2D(uTexture, vL);
        sum += texture2D(uTexture, vR);
        sum += texture2D(uTexture, vT);
        sum += texture2D(uTexture, vB);
        sum *= 0.25;
        gl_FragColor = sum * intensity;
    }
`);

const splatShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    uniform sampler2D uTarget;
    uniform float aspectRatio;
    uniform vec3 color;
    uniform vec2 point;
    uniform float radius;

    void main () {
        vec2 p = vUv - point.xy;
        p.x *= aspectRatio;
        vec3 splat = exp(-dot(p, p) / radius) * color;
        vec3 base = texture2D(uTarget, vUv).xyz;
        gl_FragColor = vec4(base + splat, 1.0);
    }
`);

const advectionManualFilteringShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    uniform sampler2D uVelocity;
    uniform sampler2D uSource;
    uniform vec2 texelSize;
    uniform vec2 dyeTexelSize;
    uniform float dt;
    uniform float dissipation;

    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
        vec2 st = uv / tsize - 0.5;

        vec2 iuv = floor(st);
        vec2 fuv = fract(st);

        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);

        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
    }

    void main () {
        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
        gl_FragColor = dissipation * bilerp(uSource, coord, dyeTexelSize);
        gl_FragColor.a = 1.0;
    }
`);

const advectionShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    uniform sampler2D uVelocity;
    uniform sampler2D uSource;
    uniform vec2 texelSize;
    uniform float dt;
    uniform float dissipation;

    void main () {
        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
        gl_FragColor = dissipation * texture2D(uSource, coord);
        gl_FragColor.a = 1.0;
    }
`);

const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uVelocity;

    void main () {
        float L = texture2D(uVelocity, vL).x;
        float R = texture2D(uVelocity, vR).x;
        float T = texture2D(uVelocity, vT).y;
        float B = texture2D(uVelocity, vB).y;

        vec2 C = texture2D(uVelocity, vUv).xy;
        if (vL.x < 0.0) { L = -C.x; }
        if (vR.x > 1.0) { R = -C.x; }
        if (vT.y > 1.0) { T = -C.y; }
        if (vB.y < 0.0) { B = -C.y; }

        float div = 0.5 * (R - L + T - B);
        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
    }
`);

const curlShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uVelocity;

    void main () {
        float L = texture2D(uVelocity, vL).y;
        float R = texture2D(uVelocity, vR).y;
        float T = texture2D(uVelocity, vT).x;
        float B = texture2D(uVelocity, vB).x;
        float vorticity = R - L - T + B;
        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
    }
`);

const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `
    precision highp float;
    precision highp sampler2D;

    varying vec2 vUv;
    varying vec2 vL;
    varying vec2 vR;
    varying vec2 vT;
    varying vec2 vB;
    uniform sampler2D uVelocity;
    uniform sampler2D uCurl;
    uniform float curl;
    uniform float dt;

    void main () {
        float L = texture2D(uCurl, vL).x;
        float R = texture2D(uCurl, vR).x;
        float T = texture2D(uCurl, vT).x;
        float B = texture2D(uCurl, vB).x;
        float C = texture2D(uCurl, vUv).x;

        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
        force /= length(force) + 0.0001;
        force *= curl * C;
        force.y *= -1.0;

        vec2 vel = texture2D(uVelocity, vUv).xy;
        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);
    }
`);

const pressureShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uPressure;
    uniform sampler2D uDivergence;

    vec2 boundary (vec2 uv) {
        return uv;
        // uncomment if you use wrap or repeat texture mode
        // uv = min(max(uv, 0.0), 1.0);
        // return uv;
    }

    void main () {
        float L = texture2D(uPressure, boundary(vL)).x;
        float R = texture2D(uPressure, boundary(vR)).x;
        float T = texture2D(uPressure, boundary(vT)).x;
        float B = texture2D(uPressure, boundary(vB)).x;
        float C = texture2D(uPressure, vUv).x;
        float divergence = texture2D(uDivergence, vUv).x;
        float pressure = (L + R + B + T - divergence) * 0.25;
        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
    }
`);

const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `
    precision mediump float;
    precision mediump sampler2D;

    varying highp vec2 vUv;
    varying highp vec2 vL;
    varying highp vec2 vR;
    varying highp vec2 vT;
    varying highp vec2 vB;
    uniform sampler2D uPressure;
    uniform sampler2D uVelocity;

    vec2 boundary (vec2 uv) {
        return uv;
        // uv = min(max(uv, 0.0), 1.0);blit
        // return uv;
    }

    void main () {
        float L = texture2D(uPressure, boundary(vL)).x;
        float R = texture2D(uPressure, boundary(vR)).x;
        float T = texture2D(uPressure, boundary(vT)).x;
        float B = texture2D(uPressure, boundary(vB)).x;
        vec2 velocity = texture2D(uVelocity, vUv).xy;
        velocity.xy -= vec2(R - L, T - B);
        gl_FragColor = vec4(velocity, 0.0, 1.0);
    }
`);

const blit = (() => {
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);
  
    return (destination) => {
        gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }
})();

let ditheringTexture = createTextureAsync('./LDR_RGB1_0.png');
// let ditheringTexture = createTextureAsync('./images/background_image.png');

const clearProgram               = new GLProgram(baseVertexShader, clearShader);
const colorProgram               = new GLProgram(baseVertexShader, colorShader);
const backgroundProgram          = new GLProgram(baseVertexShader, backgroundShader);
const displayProgram             = new GLProgram(baseVertexShader, displayShader);
const displayBloomProgram        = new GLProgram(baseVertexShader, displayBloomShader);
const displayShadingProgram      = new GLProgram(baseVertexShader, displayShadingShader);
const displayBloomShadingProgram = new GLProgram(baseVertexShader, displayBloomShadingShader);
const bloomPrefilterProgram      = new GLProgram(baseVertexShader, bloomPrefilterShader);
const bloomBlurProgram           = new GLProgram(baseVertexShader, bloomBlurShader);
const bloomFinalProgram          = new GLProgram(baseVertexShader, bloomFinalShader);
const splatProgram               = new GLProgram(baseVertexShader, splatShader);
const advectionProgram           = new GLProgram(baseVertexShader, ext.supportLinearFiltering ? advectionShader : advectionManualFilteringShader);
const divergenceProgram          = new GLProgram(baseVertexShader, divergenceShader);
const curlProgram                = new GLProgram(baseVertexShader, curlShader);
const vorticityProgram           = new GLProgram(baseVertexShader, vorticityShader);
const pressureProgram            = new GLProgram(baseVertexShader, pressureShader);
const gradienSubtractProgram     = new GLProgram(baseVertexShader, gradientSubtractShader);



function initFramebuffers () {
    let simRes = getResolution(config.SIM_RESOLUTION);
    let dyeRes = getResolution(config.DYE_RESOLUTION);

    simWidth  = simRes.width;
    simHeight = simRes.height;
    dyeWidth  = dyeRes.width;
    dyeHeight = dyeRes.height;

    const texType = ext.halfFloatTexType;
    const rgba    = ext.formatRGBA;
    const rg      = ext.formatRG;
    const r       = ext.formatR;
    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

    if (density == null)
        density = createDoubleFBO(dyeWidth, dyeHeight, rgba.internalFormat, rgba.format, texType, filtering);
    else
        density = resizeDoubleFBO(density, dyeWidth, dyeHeight, rgba.internalFormat, rgba.format, texType, filtering);

    if (velocity == null)
        velocity = createDoubleFBO(simWidth, simHeight, rg.internalFormat, rg.format, texType, filtering);
    else
        velocity = resizeDoubleFBO(velocity, simWidth, simHeight, rg.internalFormat, rg.format, texType, filtering);

    divergence = createFBO      (simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);
    curl       = createFBO      (simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);
    pressure   = createDoubleFBO(simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);

    initBloomFramebuffers();
}

function initBloomFramebuffers () {
    let res = getResolution(config.BLOOM_RESOLUTION);

    const texType = ext.halfFloatTexType;
    const rgba = ext.formatRGBA;
    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

    bloom = createFBO(res.width, res.height, rgba.internalFormat, rgba.format, texType, filtering);

    bloomFramebuffers.length = 0;
    for (let i = 0; i < config.BLOOM_ITERATIONS; i++)
    {
        let width = res.width >> (i + 1);
        let height = res.height >> (i + 1);

        if (width < 2 || height < 2) break;

        let fbo = createFBO(width, height, rgba.internalFormat, rgba.format, texType, filtering);
        bloomFramebuffers.push(fbo);
    }
}

function createFBO (w, h, internalFormat, format, type, param) {
    gl.activeTexture(gl.TEXTURE0);
    let texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

    let fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.viewport(0, 0, w, h);
    gl.clear(gl.COLOR_BUFFER_BIT);

    return {
        texture,
        fbo,
        width: w,
        height: h,
        attach (id) {
            gl.activeTexture(gl.TEXTURE0 + id);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            return id;
        }
    };
}

function createDoubleFBO (w, h, internalFormat, format, type, param) {
    let fbo1 = createFBO(w, h, internalFormat, format, type, param);
    let fbo2 = createFBO(w, h, internalFormat, format, type, param);

    return {
        get read () {
            return fbo1;
        },
        set read (value) {
            fbo1 = value;
        },
        get write () {
            return fbo2;
        },
        set write (value) {
            fbo2 = value;
        },
        swap () {
            let temp = fbo1;
            fbo1 = fbo2;
            fbo2 = temp;
        }
    }
}

function resizeFBO (target, w, h, internalFormat, format, type, param) {
    let newFBO = createFBO(w, h, internalFormat, format, type, param);
    clearProgram.bind();
    gl.uniform1i(clearProgram.uniforms.uTexture, target.attach(0));
    gl.uniform1f(clearProgram.uniforms.value, 1);
    blit(newFBO.fbo);
    return newFBO;
}

function resizeDoubleFBO (target, w, h, internalFormat, format, type, param) {
    target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);
    target.write = createFBO(w, h, internalFormat, format, type, param);
    return target;
}

function createTextureAsync (url) {
    let texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));

    let obj = {
        texture,
        width: 1,
        height: 1,
        attach (id) {
            gl.activeTexture(gl.TEXTURE0 + id);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            return id;
        }
    };

    let image = new Image();
    image.onload = () => {
        obj.width = image.width;
        obj.height = image.height;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
        console.log('image-texture loaded', image);
     };
    image.src = url;
    
    console.log('image-texture load:', url,image);
  
    return obj;
}


//*******************************************************

initFramebuffers();
//multipleSplats(parseInt(Math.random() * 20) + 3);  // MULTI SPLATS AT START UP

let lastColorChangeTime = Date.now();
pointers[0].color = config.POINTER_COLOR.getRandom();
update();

let U = 0;

// **************************************************************************************************

function update () {
    resizeCanvas();
                 
    input();
    if (!config.PAUSED)
        step(config.sdt);        // config.sdt=0.016    0.01 - 0.040

    if (typeof image === 'undefined')
         { render(null);   }
    else 
         { render(image);  }

   requestAnimationFrame(update);      // this is the Frame-Loop! ... calls itself
}
// **************************************************************************************************

function input () {
    if (splatStack.length > 0)
        multipleSplats(splatStack.pop());

    for (let i = 0; i < pointers.length; i++) {
        const p = pointers[i];
        if (p.moved) {
            splat(p.x, p.y, p.dx, p.dy, p.color);
            p.moved = false;
        }
    }

    if (lastColorChangeTime + 100 < Date.now())
    {
        lastColorChangeTime = Date.now();
        for (let i = 0; i < pointers.length; i++) {
            const p = pointers[i];
            p.color = config.COLORFUL ? generateColor() : config.POINTER_COLOR.getRandom();
        }
    }
}

function step (dt) {
    gl.disable(gl.BLEND);
    gl.viewport(0, 0, simWidth, simHeight);

    curlProgram.bind();
    gl.uniform2f(curlProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);
    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
    blit(curl.fbo);

    vorticityProgram.bind();
    gl.uniform2f(vorticityProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);
    gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
    gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
    gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
    gl.uniform1f(vorticityProgram.uniforms.dt, dt);
    blit(velocity.write.fbo);
    velocity.swap();

    divergenceProgram.bind();
    gl.uniform2f(divergenceProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);
    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
    blit(divergence.fbo);

    clearProgram.bind();
    gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE_DISSIPATION);
    blit(pressure.write.fbo);
    pressure.swap();

    pressureProgram.bind();
    gl.uniform2f(pressureProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);
    gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
    for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
        blit(pressure.write.fbo);
        pressure.swap();
    }

    gradienSubtractProgram.bind();
    gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);
    gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
    gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
    blit(velocity.write.fbo);
    velocity.swap();

    advectionProgram.bind();
    gl.uniform2f(advectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);
    if (!ext.supportLinearFiltering)
        gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / simWidth, 1.0 / simHeight);
    let velocityId = velocity.read.attach(0);
    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
    gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
    gl.uniform1f(advectionProgram.uniforms.dt, dt);
    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
    blit(velocity.write.fbo);
    velocity.swap();

    gl.viewport(0, 0, dyeWidth, dyeHeight);

    if (!ext.supportLinearFiltering)
        gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / dyeWidth, 1.0 / dyeHeight);
    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
    gl.uniform1i(advectionProgram.uniforms.uSource, density.read.attach(1));
    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
    blit(density.write.fbo);
    density.swap();
}     // !step()

function render (target) {
    if (config.BLOOM)
        applyBloom(density.read, bloom);

    if (target == null) {  // || !config.TRANSPARENT) {
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
    }
    else {
        gl.disable(gl.BLEND);
    }

    let width  = target == null ? gl.drawingBufferWidth : dyeWidth;
    let height = target == null ? gl.drawingBufferHeight : dyeHeight;

    gl.viewport(0, 0, width, height);

    if (!config.TRANSPARENT) {
        colorProgram.bind();
        let bc = config.BACK_COLOR;
        gl.uniform4f(colorProgram.uniforms.color, bc.r / 255, bc.g / 255, bc.b / 255, 1);
        blit(target);
    }

    if (config.TRANSPARENT) {
        backgroundProgram.bind();
        gl.uniform1f(backgroundProgram.uniforms.aspectRatio, canvas.width / canvas.height);
        blit(target);
    }

    if (config.SHADING) {
        let program = config.BLOOM ? displayBloomShadingProgram : displayShadingProgram;
        program.bind();
        gl.uniform2f(program.uniforms.texelSize, 1.0 / width, 1.0 / height);
        gl.uniform1i(program.uniforms.uTexture, density.read.attach(0));
        if (config.BLOOM) {
            gl.uniform1i(program.uniforms.uBloom, bloom.attach(1));
            gl.uniform1i(program.uniforms.uDithering, ditheringTexture.attach(2));
            let scale = getTextureScale(ditheringTexture, width, height);
            gl.uniform2f(program.uniforms.ditherScale, scale.x, scale.y);
        }
    }
    else {
        let program = config.BLOOM ? displayBloomProgram : displayProgram;
        program.bind();
        gl.uniform1i(program.uniforms.uTexture, density.read.attach(0));
        if (config.BLOOM) {
            gl.uniform1i(program.uniforms.uBloom, bloom.attach(1));
            gl.uniform1i(program.uniforms.uDithering, ditheringTexture.attach(2));
            let scale = getTextureScale(ditheringTexture, width, height);
            gl.uniform2f(program.uniforms.ditherScale, scale.x, scale.y);
        }
    }

    blit(target);
}  // !render

function applyBloom (source, destination) {
    if (bloomFramebuffers.length < 2)
        return;

    let last = destination;

    gl.disable(gl.BLEND);
    bloomPrefilterProgram.bind();
    let knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;
    let curve0 = config.BLOOM_THRESHOLD - knee;
    let curve1 = knee * 2;
    let curve2 = 0.25 / knee;
    gl.uniform3f(bloomPrefilterProgram.uniforms.curve, curve0, curve1, curve2);
    gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD);
    gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, source.attach(0));
    gl.viewport(0, 0, last.width, last.height);
    blit(last.fbo);

    bloomBlurProgram.bind();
    for (let i = 0; i < bloomFramebuffers.length; i++) {
        let dest = bloomFramebuffers[i];
        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, 1.0 / last.width, 1.0 / last.height);
        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));
        gl.viewport(0, 0, dest.width, dest.height);
        blit(dest.fbo);
        last = dest;
    }

    gl.blendFunc(gl.ONE, gl.ONE);
    gl.enable(gl.BLEND);

    for (let i = bloomFramebuffers.length - 2; i >= 0; i--) {
        let baseTex = bloomFramebuffers[i];
        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, 1.0 / last.width, 1.0 / last.height);
        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));
        gl.viewport(0, 0, baseTex.width, baseTex.height);
        blit(baseTex.fbo);
        last = baseTex;
    }

    gl.disable(gl.BLEND);
    bloomFinalProgram.bind();
    gl.uniform2f(bloomFinalProgram.uniforms.texelSize, 1.0 / last.width, 1.0 / last.height);
    gl.uniform1i(bloomFinalProgram.uniforms.uTexture, last.attach(0));
    gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY);
    gl.viewport(0, 0, destination.width, destination.height);
    blit(destination.fbo);
}

function blob (x, y, dx, dy, color) {
    gl.viewport(0, 0, simWidth, simHeight);
    splatProgram.bind();
    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
    gl.uniform2f(splatProgram.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);
  //  gl.uniform3f(splatProgram.uniforms.color, dx, -dy, 1.0);
    gl.uniform1f(splatProgram.uniforms.radius, RADIUS / 100.0);
    blit(velocity.write.fbo);
    velocity.swap();

    gl.viewport(0, 0, dyeWidth, dyeHeight);
    gl.uniform1i(splatProgram.uniforms.uTarget, density.read.attach(0));
    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
    blit(density.write.fbo);
    density.swap();
}  // !blob

function splat (x, y, dx, dy, color) {
    gl.viewport(0, 0, simWidth, simHeight);
    splatProgram.bind();
    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
    gl.uniform2f(splatProgram.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);
    gl.uniform3f(splatProgram.uniforms.color, dx, -dy, 1.0);
    gl.uniform1f(splatProgram.uniforms.radius, RADIUS / 100.0);
    blit(velocity.write.fbo);
    velocity.swap();

    gl.viewport(0, 0, dyeWidth, dyeHeight);
    gl.uniform1i(splatProgram.uniforms.uTarget, density.read.attach(0));
    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
    blit(density.write.fbo);
    density.swap();
}

function multipleSplats (amount) {
    for (let i = 0; i < amount; i++) {
        const color = config.COLORFUL ? generateColor() : Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = canvas.width * Math.random();
        const y = canvas.height * Math.random();
        const dx = 1000 * (Math.random() - 0.5);
        const dy = 1000 * (Math.random() - 0.5);
        splat(x, y, dx, dy, color);
    }
}

function resizeCanvas () {
    if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        initFramebuffers();
    }
}


function generateColor () {
    let c = HSVtoRGB(Math.random(), 1.0, 1.0);
    c.r *= 0.15;
    c.g *= 0.15;
    c.b *= 0.15;
    return c;
}

function HSVtoRGB (h, s, v) {
    let r, g, b, i, f, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }

    return {
        r,
        g,
        b
    };
}

function RGBToHue(r, g, b) {
  // Find greatest and smallest channel values
  let cmin = Math.min(r,g,b),
      cmax = Math.max(r,g,b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;

  // Calculate hue
  // No difference
  if (delta == 0)
    h = 0;
  // Red is max
  else if (cmax == r)
    h = ((g - b) / delta) % 6;
  // Green is max
  else if (cmax == g)
    h = (b - r) / delta + 2;
  // Blue is max
  else
    h = (r - g) / delta + 4;

  h = Math.round(h * 60);
    
  // Make negative hues positive behind 360
  if (h < 0)
      h += 360;

  return h;
}

function getResolution (resolution) {
    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
    if (aspectRatio < 1)
        aspectRatio = 1.0 / aspectRatio;

    let max = Math.round(resolution * aspectRatio);
    let min = Math.round(resolution);

    if (gl.drawingBufferWidth > gl.drawingBufferHeight)
        return { width: max, height: min };
    else
        return { width: min, height: max };
}

function getTextureScale (texture, width, height) {
    return {
        x: width / texture.width,
        y: height / texture.height
    };
}

function rgbToPointerColor(color) {
    let c = color.split(" ");
    let hue = RGBToHue(c[0], c[1], c[2]);
    let c2 = HSVtoRGB(hue/360, 1.0, 1.0);
    c2.r *= 0.15;
    c2.g *= 0.15;
    c2.b *= 0.15;
    return c2;
}

//*************************************************************************************************************************
//*************************************************************************************************************************
//*************************************************************************************************************************



canvas.addEventListener('mousemove', e => { 
    pointers[0].moved = true;
    pointers[0].dx = (e.offsetX - pointers[0].x)/4;
    pointers[0].dy = (e.offsetY - pointers[0].y)/4;
    pointers[0].x = e.offsetX;
    pointers[0].y = e.offsetY;
 //   console.log("xy ",pointers[0].x,pointers[0].y , pointers[0].dx,pointers[0].dy)
});

 canvas.addEventListener('touchmove', e => {
     e.preventDefault();
     const touches = e.targetTouches;
     for (let i = 0; i < touches.length; i++) {
         let pointer = pointers[i];
         pointer.moved = pointer.down;
         pointer.dx = (touches[i].pageX - pointer.x) * 1.0;
         pointer.dy = (touches[i].pageY - pointer.y) * 1.0;
         pointer.x = touches[i].pageX;
         pointer.y = touches[i].pageY;
     }
 }, false);

//canvas.addEventListener('mouseenter', () => {
//    pointers[0].down = true;
//    pointers[0].color = config.POINTER_COLOR.getRandom();
//});

 canvas.addEventListener('touchstart', e => {
     e.preventDefault();
     const touches = e.targetTouches;
     for (let i = 0; i < touches.length; i++) {
         if (i >= pointers.length)
             pointers.push(new pointerPrototype());
 
         pointers[i].id = touches[i].identifier;
         pointers[i].down = true;
         pointers[i].x = touches[i].pageX;
         pointers[i].y = touches[i].pageY;
         pointers[i].color = config.POINTER_COLOR.getRandom();
    }
    KeyHandler('K');  
    KeyHandler('-');  
    
 });

canvas.addEventListener("mousedown", () => {
   
});
  canvas.addEventListener("mouseup", () => {
 
  });

//window.addEventListener('mouseleave', () => {
//    pointers[0].down = false;
//});

//window.addEventListener('touchend', e => {
//    const touches = e.changedTouches;
//    for (let i = 0; i < touches.length; i++)
//        for (let j = 0; j < pointers.length; j++)
//            if (touches[i].identifier == pointers[j].id)
//                pointers[j].down = false;
//});

// MIDI
 

//************************************************
//************************************************
//************************************************


function SL_24_Patterns(OSC_DEMO24,PPQ24) {       
  // 24 pulses per quarter note - pattern builder
  if(PPQ24<25) { PPQ=PPQ24; }
    PPQ=PPQ+1; 
    if( PPQ>=25)  { PPQ=1; }
   //console.log('ppq24 ',PPQ24,PPQ);

 // console.log('ppq:' ,PPQX,PPQY, PPQX_DIR, PPQY_DIR, Pdx,Pdy);
   let wLim = canvas.width/2+canvas.width*config.OSC_DIAMETER/256;
   let hLim = canvas.height/2+canvas.height*config.oscVel/256;
   let wLOLim = canvas.width-wLim;
   let hLOLim = canvas.height-hLim;
   //console.log('LIMITS;',wLOLim, hLOLim,wLim,hLim)
    if(PPQX_DIR===true && PPQX<wLim)  PPQX=PPQX+config.speed;
    if(PPQY_DIR===true && PPQY<hLim)  PPQY=PPQY+config.speed;
    if(PPQX_DIR===false && PPQX>wLOLim)  PPQX=PPQX-config.speed;
    if(PPQY_DIR===false && PPQY>hLOLim)  PPQY=PPQY-config.speed;
    if(PPQX>=wLim || PPQX<=wLOLim) PPQX_DIR=!PPQX_DIR;
    if(PPQY>=hLim || PPQY<=hLOLim) PPQY_DIR=!PPQY_DIR;
    var de =  config.DELTASIZE;
    if(PPQX_DIR) Pdx = -de ; else Pdx = de;
    if(PPQY_DIR) Pdy = -de ; else Pdy = de;
  
    const color = config.COLORFUL ? generateColor() : Object.assign({}, config.POINTER_COLOR.getRandom());
    color.r *= 2.0;
    color.g *= 2.0;
    color.b *= 2.0; 
  // splat(PPQX,PPQY,Pdx,Pdy,color);
    
    pointers[0].dx = de * config.DELTAMULT;
    pointers[0].dy = de * config.DELTAMULT;
    pointers[0].x = PPQX;
    pointers[0].y = PPQY;

    pointers.x = PPQX;
    pointers.y = PPQY;
    let pi = 3.141;
    var d = LFO_PHASE*(2 * pi * (PPQ-1))/24;
        
    if(OSC_DEMO24===1)  {
        splat(PPQX,PPQY,Pdx,Pdy,color); 
        }
    if(OSC_DEMO24===2)  {
        splat(canvas.width/2,PPQY,Pdx,Pdy,color); 
        }
    if(OSC_DEMO24===3)  {
        splat(canvas.width/4,PPQY,Pdx,Pdy,color); 
        splat(canvas.width*3/4,PPQY,Pdx,Pdy,color); 
        }
    if(OSC_DEMO24===4)  {
        splat(canvas.width/4,PPQY,Pdx,Pdy,color); 
        splat(canvas.width*2/4,PPQY,Pdx,Pdy,color); 
        splat(canvas.width*3/4,PPQY,Pdx,Pdy,color); 
        }
    if(config.OSC_DEMO24===5)  {
        splat(PPQX,canvas.height/2,Pdx,Pdy,color); 
        } 
    if(OSC_DEMO24===6)  {
        splat(PPQX,canvas.height/3,Pdx,Pdy,color); 
        splat(PPQX,canvas.height*2/3,Pdx,Pdy,color); 
        } 
    if(OSC_DEMO24===7)  {
        splat(PPQX,canvas.height/4,Pdx,Pdy,color); 
        splat(PPQX,canvas.height*3/4,Pdx,Pdy,color); 
        } 
   
    if(OSC_DEMO24===8)  {           // ONE TRIANGLE
        let cx = canvas.width/2+config.LFO_CX1;
        let cy = canvas.height*5/9+config.LFO_CY1;
        let ll = 4*config.OSC_DIAMETER+40;
        let hx = cx-ll/2 + (ll/24)*PPQ;
        let hy = cy+ll/4;  // 
        let vx = (cx-ll/2) + (ll/48)*PPQ;
        let vx2 = (cx+ll/2) - (ll/48)*PPQ;
        let vy = (cy+ll/4) - ll*(0.6)*PPQ/24;

        var de =  config.DELTASIZE/500;
        Pdx = de *(cx-hx)*LFO_PHASE; 
        Pdy = de *(cy-hy)*LFO_PHASE; 
        splat(hx,hy,Pdx,Pdy,color); 
       // console.log('TRIANGLE:' ,hx,hy,vx,vy, Pdx,Pdy);

        Pdx = de *(cx-vx)*LFO_PHASE; 
        Pdy = de *(cy-vy)*LFO_PHASE; 
        splat(vx,vy,Pdx,Pdy,color);
        Pdx = de *(cx-vx2)*LFO_PHASE; 
         splat(vx2,vy,Pdx,Pdy,color); 
       
        }
        
    if(OSC_DEMO24===9)  {       // 2 TRIANGLES TOP, BOT
        let cx = canvas.width/2+config.LFO_CX1;
        let cy = canvas.height*2/9+config.LFO_CY1;
        let ll = 4*config.OSC_DIAMETER+40;
        let hx = cx-ll/2 + (ll/24)*PPQ;
        let hy = cy-ll/4;  // 
        let vx = (cx-ll/2) + (ll/48)*PPQ;
        let vx2 = (cx+ll/2) - (ll/48)*PPQ;
        let vy =  (cy-ll/4) + ll*(0.6)*PPQ/24;

        var de =  config.DELTASIZE/700;
        Pdx = de *(cx-hx)*LFO_PHASE; 
        Pdy = de *(cy-hy)*LFO_PHASE; 
        splat(hx,hy,Pdx,Pdy,color); 
      //  console.log('TOP TRIANGLE:' ,hx,hy,vx,vy, Pdx,Pdy);

        Pdx = de *(cx-vx)*LFO_PHASE; 
        Pdy = de *(cy-vy)*LFO_PHASE; 
        splat(vx,vy,Pdx,Pdy,color);
        Pdx = de *(cx-vx2)*LFO_PHASE; 
         splat(vx2,vy,Pdx,Pdy,color); 
       
        cy = canvas.height*7/9+LFO_CY2;
        ll = 4*config.OSC_DIAMETER+40;
        hx = cx-ll/2 + (ll/24)*PPQ;
        hy = cy+ll/4;  // 
        vx = (cx-ll/2) + (ll/48)*PPQ;
        vx2 = (cx+ll/2) - (ll/48)*PPQ;
        vy = (cy+ll/4) - ll*(0.6)*PPQ/24;

         de =  config.DELTASIZE/700;
        Pdx = de *(cx-hx)*LFO_PHASE; 
        Pdy = de *(cy-hy)*LFO_PHASE; 
        splat(hx,hy,Pdx,Pdy,color); 
       
        Pdx = de *(cx-vx)*LFO_PHASE; 
        Pdy = de *(cy-vy)*LFO_PHASE; 
        splat(vx,vy,Pdx,Pdy,color);
        Pdx = de *(cx-vx2)*LFO_PHASE; 
         splat(vx2,vy,Pdx,Pdy,color); 
       
        }  
   
    if(OSC_DEMO24===10)  {      // 2 TRIANGLES, SIDE BY SIDE
        let cx = canvas.width/4+config.LFO_CX1;
        let cy = canvas.height*5/9+config.LFO_CY1;
        let ll = 4*config.OSC_DIAMETER+40;
        let hx = cx-(ll/2) + (ll/24)*PPQ;
        let hy = cy-(LFO_PHASE*ll/4);  // 
        let vx = (cx-ll/2) + (ll/48)*PPQ;
        let vx2 = (cx+ll/2) - (ll/48)*PPQ;
        let vy =  (cy-(LFO_PHASE*ll/4)) + LFO_PHASE*ll*(0.6)*PPQ/24;

        var de =  config.DELTASIZE/700;
        Pdx = de *(cx-hx)*LFO_PHASE; 
        Pdy = de *(cy-hy)*LFO_PHASE; 
        splat(hx,hy,Pdx,Pdy,color); 
        Pdx = de *(cx-vx)*LFO_PHASE; 
        Pdy = de *(cy-vy)*LFO_PHASE; 
        splat(vx,vy,Pdx,Pdy,color);
        Pdx = de *(cx-vx2)*LFO_PHASE; 
         splat(vx2,vy,Pdx,Pdy,color); 
       

        cx = canvas.width*3/4+config.LFO_CX2;
        cy = canvas.height*5/9+config.LFO_CY2;
        ll = 4*config.OSC_DIAMETER+40;
        hx = cx-ll/2 + (ll/24)*PPQ;
        hy = cy+ll/4;  // 
        vx = (cx-ll/2) + (ll/48)*PPQ;
        vx2 = (cx+ll/2) - (ll/48)*PPQ;
        vy = (cy+ll/4) - ll*(0.6)*PPQ/24;

         de =  config.DELTASIZE/500;
        Pdx = de *(cx-hx)*LFO_PHASE; 
        Pdy = de *(cy-hy)*LFO_PHASE; 
        splat(hx,hy,Pdx,Pdy,color); 
        Pdx = de *(cx-vx)*LFO_PHASE; 
        Pdy = de *(cy-vy)*LFO_PHASE; 
        splat(vx,vy,Pdx,Pdy,color);
        Pdx = de *(cx-vx2)*LFO_PHASE; 
         splat(vx2,vy,Pdx,Pdy,color); 
       
        }  
   
    if(OSC_DEMO24===11)  {      // STAR = 2 TRIANGLES
        let cx = canvas.width/2+config.LFO_CX1;
        let cy = canvas.height*1/2+config.LFO_CY1;
        let ll = 4*config.OSC_DIAMETER+40;
        let hx = cx-(ll/2) + (ll/24)*PPQ;
        let hy = cy-(ll/4);  // 
        let vx = (cx-ll/2) + (ll/48)*PPQ;
        let vx2 = (cx+ll/2) - (ll/48)*PPQ;
        let vy =  (cy-(ll/4)) + ll*(0.76)*PPQ/24;

        var de =  config.DELTASIZE/700;
        Pdx = de *(cx-hx)*LFO_PHASE; 
        Pdy = de *(cy-hy)*LFO_PHASE; 
        splat(hx,hy,Pdx,Pdy,color); 
        Pdx = de *(cx-vx)*LFO_PHASE; 
        Pdy = de *(cy-vy)*LFO_PHASE; 
        splat(vx,vy,Pdx,Pdy,color);
        Pdx = de *(cx-vx2)*LFO_PHASE; 
        splat(vx2,vy,Pdx,Pdy,color); 
       

        cx = canvas.width*2/4+config.LFO_CX2;
        cy = canvas.height*1/2+config.LFO_CY2;
        ll = 4*config.OSC_DIAMETER+40;
        hx = cx-ll/2 + (ll/24)*PPQ;
        hy = cy+ll/4;  // 
        vx = (cx-ll/2) + (ll/48)*PPQ;
        vx2 = (cx+ll/2) - (ll/48)*PPQ;
        vy = (cy+ll/4) - ll*(0.76)*PPQ/24;

         de =  config.DELTASIZE/500;
        Pdx = de *(cx-hx)*LFO_PHASE; 
        Pdy = de *(cy-hy)*LFO_PHASE; 
        splat(hx,hy,Pdx,Pdy,color); 
        Pdx = de *(cx-vx)*LFO_PHASE; 
        Pdy = de *(cy-vy)*LFO_PHASE; 
        splat(vx,vy,Pdx,Pdy,color);
        Pdx = de *(cx-vx2)*LFO_PHASE; 
        splat(vx2,vy,Pdx,Pdy,color); 
       
        }  
   
    Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(d)*config.DELTAMULT*10 ;
    Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(d)*config.DELTAMULT*10 ; 
   
   if(OSC_DEMO24===12)  {       //SINGLE CIRCLE -
        
        pointers.x = (canvas.width/2+config.LFO_CX1)-   (3*config.OSC_DIAMETER*Math.cos(d));
        pointers.y = (canvas.height*2/4+config.LFO_CY1)-(3*config.OSC_DIAMETER*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 
       // console.log("D12:",PPQ, pointers.x, pointers.y, Pdx, Pdy, "d=",d)
        }
    
   if(OSC_DEMO24===13)  {
        pointers.x = (canvas.width/2+config.LFO_CX1)+  (3*config.OSC_DIAMETER*Math.cos(d));
        pointers.y = (canvas.height*2/4+config.LFO_CY1)+(3*config.OSC_DIAMETER*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 
        //console.log("D13:", pointers.x, pointers.y, Pdx, Pdy, "d=",d)
        }
    
   if(OSC_DEMO24===14)  {  
        pointers.x = (canvas.width*2/8+config.LFO_CX1)-  (3*config.OSC_DIAMETER*Math.cos(d));
        pointers.y = (canvas.height*1/2+config.LFO_CY1)-(3*config.OSC_DIAMETER*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 

        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(pi-d)*config.DELTAMULT*10 ;
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(pi-d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width*6/8+config.LFO_CX2)-  (3*config.OSC_DIAMETER*Math.cos(pi-d));
        pointers.y = (canvas.height*1/2+config.LFO_CY2)-(3*config.OSC_DIAMETER*Math.sin(pi-d)); 
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y, -Pdx,-Pdy,color); 
        //console.log("D14:", pointers.x, pointers.y, Pdx, Pdy, "d=",d)
        }
     
   if(OSC_DEMO24===15)  {  
        pointers.x = (canvas.width*2/8+config.LFO_CX1)+  (3*config.OSC_DIAMETER*Math.cos(d));
        pointers.y = (canvas.height*1/2+config.LFO_CY1)+(3*config.OSC_DIAMETER*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 

        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(pi-d)*config.DELTAMULT*10 ;
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(pi-d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width*6/8+config.LFO_CX2)+ (3*config.OSC_DIAMETER*Math.cos(pi-d));
        pointers.y = (canvas.height*1/2+config.LFO_CY2)+(3*config.OSC_DIAMETER*Math.sin(pi-d)); 
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y, -Pdx,-Pdy,color); 
        //console.log("D15:", pointers.x, pointers.y, Pdx, Pdy, "d=",d)
        }
     
   if(OSC_DEMO24===16)  {  
        let mag = config.OSC_DIAMETER;
        pointers.x = (canvas.width*2/8+config.LFO_CX1)-   (3*mag*Math.cos(d));  //LIPS-EYES
        pointers.y = (canvas.height*1/2+config.LFO_CY1)+(3*mag*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 

        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(pi-d)*config.DELTAMULT*10 ;  // REVERSED
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(pi-d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width*6/8+config.LFO_CX2)-   (3*mag*Math.cos(d));
        pointers.y = (canvas.height*1/2+config.LFO_CY2)-(3*mag*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y, -Pdx,-Pdy,color); 
        //console.log("D16:", pointers.x, pointers.y, Pdx, Pdy, "d=",d)
        }
    
        if(OSC_DEMO24===17)  { 
        let mag = config.OSC_DIAMETER;
       
        pointers.x = (canvas.width*2/8+config.LFO_CX1)+  (3*config.OSC_DIAMETER*Math.cos(d));
        pointers.y = (canvas.height*1/3+config.LFO_CY1)+(3*config.OSC_DIAMETER*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 

        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(pi-d)*config.DELTAMULT*10 ;  //REVERSED
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(pi-d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width*6/8-config.LFO_CX1)+ (3*config.OSC_DIAMETER*Math.cos(pi-d));
        pointers.y = (canvas.height*1/3+config.LFO_CY1)+(3*config.OSC_DIAMETER*Math.sin(pi-d)); 
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y, -Pdx,-Pdy,color); 

        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(d)*config.DELTAMULT*10 ;  //LIPS - 0 degree phase
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width/2+config.LFO_CX2)-   (3*mag*Math.cos(d));   //lips
        pointers.y = (canvas.height*2/3+config.LFO_CY2)+(3*mag*Math.sin(d));
        splat(pointers.x , pointers.y,Pdx,Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 
        }

    if(OSC_DEMO24===18)  {  //NEW - 2 EYES, VERTICAL MOUTH
        let mag = config.OSC_DIAMETER;
        
        pointers.x = (canvas.width*2/8+config.LFO_CX1)+  (3*config.OSC_DIAMETER*Math.cos(d));
        pointers.y = (canvas.height*1/3+config.LFO_CY1)+(3*config.OSC_DIAMETER*Math.sin(d));
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 

        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(pi-d)*config.DELTAMULT*10 ;  //REVERSED
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(pi-d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width*6/8-config.LFO_CX1)+ (3*config.OSC_DIAMETER*Math.cos(pi-d));
        pointers.y = (canvas.height*1/3+config.LFO_CY1)+(3*config.OSC_DIAMETER*Math.sin(pi-d)); 
        splat(pointers.x , pointers.y, Pdx, Pdy,color); 
        splat(pointers.x , pointers.y, -Pdx,-Pdy,color); 
 
        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(d)*config.DELTAMULT*10 ;  //LIPS - 0 degree phase
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width/2+config.LFO_CX2)+   (3*mag*Math.cos(d));   //lips
        pointers.y = (canvas.height*2/3+config.LFO_CY2)-(3*mag*Math.sin(d));
        splat(pointers.x , pointers.y,Pdx,Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 
        }
        
    if(OSC_DEMO24===19)  {  //NEW - VERTICAL
        let mag = config.OSC_DIAMETER;
        Pdx = (config.oscVel + config.DELTASIZE)*Math.cos(d)*config.DELTAMULT*10 ;  //LIPS - 0 degree phase
        Pdy = (config.oscVel + config.DELTASIZE)*Math.sin(d)*config.DELTAMULT*10 ; 
        pointers.x = (canvas.width/2+config.LFO_CX1)+   (3*mag*Math.cos(d));   //lips
        pointers.y = (canvas.height*2/4+config.LFO_CY1)-(3*mag*Math.sin(d));
        splat(pointers.x , pointers.y,Pdx,Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 
        }
        
    if(OSC_DEMO24===20)  {  //NEW - double helix
        let mag = (config.DELTAMULT )/32;
        let cx = canvas.width/3+config.LFO_CX1;
        let cy = canvas.height*8/9+config.LFO_CY1;
        let hy = cy-canvas.height*7/9*(1/24)*PPQ;
        let hx = cx+Math.sin(mag*3*d)*config.OSC_DIAMETER/50*(config.DELTASIZE) ;  //
        let hxx = cx-Math.sin(mag*3*d)*config.OSC_DIAMETER/50*(config.DELTASIZE) ;  //
      
        var de =  config.oscVel/340;
        Pdx = de*(cx-hx)*LFO_PHASE; 
        Pdy = 0; 
        splat(hx,hy,Pdx,Pdy,color); 
        Pdx = de *(cx-hxx)*LFO_PHASE; 
        splat(hxx,hy,Pdx,Pdy,color); 

        if(PPQ==24) { //complete phase of sin           
            d = LFO_PHASE*(2 * pi * (PPQ))/24;
            let hy = cy-canvas.height*7/9*(1/24)*(PPQ+1);
            splat(cx,hy,0,0,color); 
            }
        }
        if(OSC_DEMO24===21)  {  //NEW - double helix x 3
        let mag = (config.DELTAMULT )/32;
        let cx = canvas.width/3+config.LFO_CX1;
        let cy = canvas.height*8/9+config.LFO_CY1;
        let hy = cy-canvas.height*7/27*(1/24)*PPQ;
        let hx = cx+Math.sin(mag*3*d)*config.OSC_DIAMETER/50*(config.DELTASIZE) ;  //
        let hxx = cx-Math.sin(mag*3*d)*config.OSC_DIAMETER/50*(config.DELTASIZE) ;  //
      
        var de =  config.oscVel/340;
        Pdx = de*(cx-hx)*LFO_PHASE; 
        Pdy = 0;
        const color2 = config.COLORFUL ? generateColor() : Object.assign({}, config.POINTER_COLOR.getRandom());
        const color3 = config.COLORFUL ? generateColor() : Object.assign({}, config.POINTER_COLOR.getRandom());
        let cyc = canvas.height*7/27; 
        splat(hx,hy,Pdx,Pdy,color); 
        splat(hx,hy-cyc,Pdx,Pdy,color2); 
        splat(hx,hy-2*cyc,Pdx,Pdy,color3); 
        Pdx = de *(cx-hxx)*LFO_PHASE; 
        splat(hxx,hy,Pdx,Pdy,color); 
        splat(hxx,hy-cyc,Pdx,Pdy,color2); 
        splat(hxx,hy-2*cyc,Pdx,Pdy,color3); 

        if(PPQ==24) { //complete phase of sin           
            d = LFO_PHASE*(2 * pi * (PPQ))/24;
            let hy = cy-canvas.height*7/9*(1/24)*(PPQ+1);
            splat(cx,hy,0,0,color); 
            }
        }
     
    if(OSC_DEMO24===22)  {  //NEW - double helix - HORIZONTAL
        let mag = (config.DELTAMULT )/32;
        let cy = canvas.height/2+config.LFO_CY1;
        let cx = canvas.width*8/9+config.LFO_CX1;
        let hx = cx-canvas.width*7/9*(1/24)*PPQ;
        let hy = cy+Math.sin(mag*3*d)*config.OSC_DIAMETER/50*(config.DELTASIZE) ;  //
        let hyy = cy-Math.sin(mag*3*d)*config.OSC_DIAMETER/50*(config.DELTASIZE) ;  //
       
        var de =  config.oscVel/340;
        Pdy = de*(cy-hy)*LFO_PHASE; 
        Pdx = 0; 
        splat(hx,hy,Pdx,Pdy,color); 
        Pdy = de *(cy-hyy)*LFO_PHASE; 
        splat(hx,hyy,Pdx,Pdy,color); 

        if(PPQ==24) { //complete phase of sin           
            d = LFO_PHASE*(2 * pi * (PPQ))/24;
            let hx = cx-canvas.width*7/9*(1/24)*(PPQ+1);
            splat(hx,cy,0,0,color); 
            }
        }

    if(OSC_DEMO24===23)  { 
        let mag = config.OSC_DIAMETER;
        pointers.x = (canvas.width/2+config.LFO_CX1)-   (3*mag*Math.cos(d));
        pointers.y = (canvas.height*2/4+config.LFO_CY1)+(3*mag*Math.sin(d));
        splat(pointers.x , pointers.y,Pdx,Pdy,color); 
        splat(pointers.x , pointers.y,-Pdx,-Pdy,color); 
    //  console.log("D20:", pointers.x, pointers.y, Pdx, Pdy, "d=",d)
        }
}  // !function SL_24_Patterns()



  function SequenceLoop()  {
   // AudioFreqLoop();        // fft analysis loop - call repeatedly
   // AudioFreqLoop();        // fft analysis loop - call repeatedly
    PPQcnt=PPQcnt+1; 
    if( PPQcnt>24)  { PPQcnt=1; }
    if(config.OSC_DEMO_FLAG&&!config.PAUSED)  {
        RADIUS = config.OSC_RADIUS; 
        SL_24_Patterns(config.OSC_DEMO,PPQcnt);  // call 24 times per q note
      //  console.log("SEQ Loop24:", PPQcnt);
        } 
          
    if(config.BKColorChangeFLAG && (PPQ===4||PPQ===8||PPQ===12||PPQ===18||PPQ===24) )  {   // runs 5 of 24 times
        config.BACK_COLOR.r=config.BACK_COLOR.r+DR;
        if(config.BACK_COLOR.r>150)  {DR=-1}
        if(config.BACK_COLOR.r<2)  {DR=1;}
        config.BACK_COLOR.b=config.BACK_COLOR.b+DB;
        if(config.BACK_COLOR.b<2)  {DB= 1;}
        if(config.BACK_COLOR.b>200)  {DB=-1;}
        }

    RADIUS = config.SPLAT_RADIUS; 
    if(config.RUN_FLAG && !config.PAUSED)  {
    
     if( PPQcnt===1 || PPQcnt===2|| PPQcnt===3|| PPQcnt===4)  {   // 2 PHASE 24 PPQ
       // console.log('PPQcnt 1&2', PPQcnt,config.DEMO_Index);
      // console.log("SEQ LoopPhase:", PPQcnt);
    
        if ( config.DEMO_Index>=12 && config.DEMO_Index<=23 )  {  
        
           for (let i = PPQcnt; i < (25); i=i+4) {
                SL_24_Patterns(config.DEMO_Index,i);       // call 24 times per q note
             //  console.log('SeqLoop: K=',config.DEMO_Index,i," Phase=",PPQcnt);
                }
 
            }  // ! Demo Index 12-20
        }  // ! 2 PHASE 24 PPQ
 
      if( PPQcnt===1)  {   // 15 DEMOS
      //  console.log("SEQ Loop1:", PPQcnt);
    
        if (config.DEMO_Index===1)  {
            KeyHandler('q');  
            KeyHandler('w');  
            KeyHandler('e');  
            KeyHandler('r');  
            }
        if (config.DEMO_Index===3)  {                  
            KeyHandler('t');  
        //  KeyHandler('y');  
        //  KeyHandler('u');  
            KeyHandler('i');    
            }
        if (config.DEMO_Index===2)  {    
            KeyHandler('a');  
            KeyHandler('s');  
            KeyHandler('d');  
            KeyHandler('f');  
            }    
        if (config.DEMO_Index===4)  {    
        //   KeyHandler('t');  
            KeyHandler('y');  
            KeyHandler('u');  
        //  KeyHandler('i');    
            }
        if (config.DEMO_Index===5)  {    
        //   KeyHandler('g');  
            KeyHandler('e');  
        //  KeyHandler('j');  
        //  KeyHandler('k');  
        //  KeyHandler('E');  
        
            }
        if (config.DEMO_Index===6)  {    
              //  KeyHandler('1');  
             //  KeyHandler('j');  
            KeyHandler('k');  
            }
        if (config.DEMO_Index===7)  {    
            KeyHandler('a');  
            KeyHandler('d'); 
        //   KeyHandler('u');  
        //   KeyHandler('y');   
            }
        if (config.DEMO_Index===8)  {    
            KeyHandler('e');  
            KeyHandler('u');  
        //  KeyHandler('d');  
            // KeyHandler('g');  
            }
        if (config.DEMO_Index===9)  {    
                KeyHandler('g');  
                KeyHandler('j');  
            } 
        if (config.DEMO_Index===10)  {
        //  KeyHandler('u');  
            KeyHandler('k');  
            KeyHandler('h');  
            }    
        if (config.DEMO_Index===11)  {    
            KeyHandler('R');  
            } 
            // console.log('Seq Loop');
        }   // ! PPQ=1

 if (config.DemoSequence_Flag) {
    SLcount++;
    if (SLcount>60*24) {
        SLcount = 0;
        KeyHandler('K');
        console.log('DEMO Seq inc K');
        
        if(config.DEMO_Index>=22)  {
            config.DEMO_Index=0;
           KeyHandler('-');  
            console.log('DEMO Seq inc -');   }
        }
    }
   else {
    SLcount++;
    if (SLcount>30*24) {
        SLcount = 0;
        Load();
    }
   }

  }  // ! RUN FLAG AND PAUSED
}   // !SeqLoop()

//************************************************
// MIDI CONFIG
let midiOutput = null;
let currentSequenceId = -1;
const START = 41;
let intervals = [0, 4, 7, 11, 12, 11, 7, 4];
let sequence =  intervals.map(x => x + START);
const NOTE_ON = 0x90;
const NOTE_OFF = 0x80;
const NOTE_DURATION = 300;
//************************************************


function UpdateAPC20_MIDI() {     // sends note-off's to btns to initialize
    let vel = 127;
    if(config.RUN_FLAG) { 
           midiOutput.send([NOTE_ON + 0, 50, 127]); 
           midiOutput.send([NOTE_ON + 2, 50, 0x7F]); } 
    else { midiOutput.send([NOTE_OFF + 0, 50, 0]);
           midiOutput.send([NOTE_OFF + 2, 50, 0]);  }
    if(config.OSC_DEMO_FLAG) { 
           midiOutput.send([NOTE_ON + 1, 50, 127]); 
           midiOutput.send([NOTE_ON + 3, 50, 0x7F]); } 
    else { midiOutput.send([NOTE_OFF + 1, 50, 0]); 
           midiOutput.send([NOTE_OFF + 3, 50, 0]); } 
    
    if(config.DemoSequence_Flag) {   // btn 7
           midiOutput.send([NOTE_ON + 7, 50, 127]); } 
    else { midiOutput.send([NOTE_OFF + 7, 50, 0]); }
    if(config.LFO_PHASE_Flag) {   // btn 8
           midiOutput.send([NOTE_ON + 7, 50, 127]); } 
    else { midiOutput.send([NOTE_OFF + 7, 50, 0]); }

   // if(config.LFO_EN) { 
    if(config.LFO_CY2_flag) { 
           midiOutput.send([NOTE_ON + 0, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 0, 49, 0]); }
    if(config.LFO_Colorthrob) { 
           midiOutput.send([NOTE_ON + 1, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 1, 49, 0]); }
    if(config.LFO_mvel) { 
           midiOutput.send([NOTE_ON + 2, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 2, 49, 0]); }
    if(config.LFO_oscVel) { 
           midiOutput.send([NOTE_ON + 3, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 3, 49, 0]); }
    if(config.LFO_oscDiam) { 
           midiOutput.send([NOTE_ON + 4, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 4, 49, 0]); }
    if(config.LFO_CX1_flag) { 
           midiOutput.send([NOTE_ON + 5, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 5, 49, 0]); }
    if(config.LFO_CX2_flag) { 
           midiOutput.send([NOTE_ON + 6, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 6, 49, 0]); }
    if(config.LFO_CY1_flag) { 
           midiOutput.send([NOTE_ON + 7, 49, 127]); } 
    else { midiOutput.send([NOTE_OFF + 7, 49, 0]); }
  
}  // !UpdateAPC20_MIDI()


function InitAPC20_MIDI() {    
    for (let i=0;i<8;i++)   {       // sends note-off's to btns to initialize
        midiOutput.send([NOTE_OFF + i, 48, 0x00]);
        console.log ('MIDI Output:' , NOTE_OFF + i, 48, 0x00);
        midiOutput.send([NOTE_OFF + i, 49, 0x00]);
        midiOutput.send([NOTE_OFF + i, 50, 0x00]);
        }  // /for
        UpdateAPC20_MIDI();
}  // !InitAPC20_MIDI()

const playSeq = function() {
  if (currentSequenceId >= 0) {
    midiOutput.send([NOTE_OFF, sequence[currentSequenceId], 0x7f]);
  }
  currentSequenceId++;
  if (currentSequenceId >= sequence.length) {
    currentSequenceId = 0;
  }
  midiOutput.send([NOTE_ON, sequence[currentSequenceId], 0x7f]);
  console.log ('MIDI Output:' , NOTE_ON, sequence[currentSequenceId], 0x7f);
  setTimeout(playSeq, NOTE_DURATION);
}    // !PlaySeq


function connect() {
  navigator.requestMIDIAccess()
  .then(
    (midi) => midiReady(midi),
    (err) => console.log('Something went wrong - NO MIDI', err));
    }   // ! connect()

function midiReady(midi) {
    
  // Also react to device changes.
  midi.addEventListener('statechange', (event) => initDevices(event.target));
  initDevices(midi); // see the next section!
 // console.log('MIDI InitDevices complete. ');
 
    // MIDI devices that you send data to.
    const outputs = midi.outputs.values();
    console.log('MIDI Output Ports:', outputs);
    for(const output of outputs) {
        console.log('MIDI Out port:' , output);
        midiOutput = output;
        }
    //playSeq();
    InitAPC20_MIDI();
    };  // ! midiReady

 
 
 //  outputs.send([0x90, 0x3C, 0x80]);  // hexadecimal
 // outputs.send([144, 60, 128]);      // decimal
 

function initDevices(midi) {
  // Reset.
  for (var input of midi.inputs.values()) {
        input.onmidimessage = midiMessageReceived;
    }
 
  // MIDI devices that send you data.
  const inputs = midi.inputs.values();
//  console.log('inputs:' , inputs);

  for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
  //  midiIn.push(input.value);
    console.log('input.value:' , input.value);
    }
  
}  // ! initDevices

function midiMessageReceived(event) {
  // MIDI commands we care about. 
  // console.log(event);    // print raw packet
  
  const NOTE_ON = 9;
  const NOTE_OFF = 8;
  const AFTERTOUCH = 10;    // A = Aftertouch
  const CC = 11;            // B = Continuous Control Change (2)
  const PGM_CHANGE = 12;    // C = PGM Change (2)
  const PRESSURE = 13;      // D = PRESSURE (1)
  const PITCH_BEND = 14;    // E = PITCH BEND (2)
 
  const ch = (event.data[0] & 15)+1;
  const cmd = event.data[0] >> 4;
  const pitch = event.data[1];
  const velocity = (event.data.length > 2) ? event.data[2] : 1;
  // You can use the timestamp to figure out the duration of each note.
  const timestamp = Date.now();
  let Note = 0; 
  
  if (cmd === NOTE_OFF || (cmd === NOTE_ON && velocity === 0)) {
    console.log('NoteOff:',cmd,pitch,velocity );
 
   if (pitch == 50)  { // apc20 Actuator Btns Row
        if(ch===1) { config.RUN_FLAG=false;    }
        if(ch===2) { config.OSC_DEMO_FLAG=false; }
        if(ch===3) {Note = ('K');}
        if(ch===4) {Note = ('-');}
        if(ch===5) {Note = ('6');}
        if(ch===6) {Note = ('1');}
        if(ch===7) { config.DemoSequence_Flag = false; }
        if(ch===8) { LFO_PHASE = -1; config.LFO_PHASE_Flag = false; }
        }
    if (pitch == 49)  { // apc20 SOLO/CUE Btns Row - BLUE
     //   if(ch===1) { config.LFO_EN = false; }
        if(ch===2) { config.LFO_Colorthrob = false; }
        if(ch===3) { config.LFO_mvel = false; }
        if(ch===4) { config.LFO_oscVel = false; }
        if(ch===5) { config.LFO_oscDiam = false; }
        if(ch===6) { config.LFO_CX1_flag = false; }
        if(ch===7) { config.LFO_CY1_flag = false;}
        if(ch===8) { config.LFO_CX2_flag = false; }
        if(ch===1) { config.LFO_CY2_flag = false; }
   
        }
   if (pitch == 48)  { // apc20 Record Btns Row - RED
        if(ch===1) { AltFlag[0] = false; }
        if(ch===2) { AltFlag[1] = false; }
        if(ch===3) { AltFlag[2] = false; }
        if(ch===4) { AltFlag[3] = false; }
        if(ch===5) { AltFlag[4] = false; }
        if(ch===6) { AltFlag[5] = false; }
        if(ch===7) { AltFlag[6] = false; }
        if(ch===8) { AltFlag[7] = false; }       
        }
        UpdateAPC20_MIDI;
/*
    if (ch === 1 && velocity == 127)  { // MIDIMIX CONTROLLER - MUTE Row
        if(pitch==1) { config.RUN_FLAG=false;    }
        if(pitch==4) { config.OSC_DEMO_FLAG=false; }
        if(pitch==7) {Note = ('K');}
        if(pitch==10) {Note = ('-');}
        if(pitch==13) {Note = ('6');}
        if(pitch==16) {Note = ('1');}
        if(pitch==19) { config.DemoSequence_Flag = false; }
        if(pitch==22) { LFO_PHASE = -1; config.LFO_PHASE_Flag = false; }
        }
    if (ch === 1 && velocity == 127)  { // // MIDIMIX CONTROLLER - REC ARM Row
        if(pitch==3) { config.LFO_Colorthrob = false; }
        if(pitch==6) { config.LFO_mvel = false; }
        if(pitch==9) { config.LFO_oscVel = false; }
        if(pitch==12) { config.LFO_oscDiam = false; }
        if(pitch==15) { config.LFO_CX1_flag = false; }
        if(pitch==18) { config.LFO_CY1_flag = false;}
        if(pitch==21) { config.LFO_CX2_flag = false; }
        if(pitch==23) { config.LFO_CY2_flag = false; }
        }
  */     

         gui.updateDisplay();
    }    // /NoteOff

   else if (cmd === NOTE_ON) {
    console.log('NoteOff:',cmd,pitch,velocity );
    let Note = 0;
      /*
      if (pitch == 52)
      Note = ('t');    // press key t
      if (pitch == 53)
      Note = ('y');    // press key y
      if (pitch == 54)
      Note = ('u');    // press key u
      if (pitch == 55)
      Note = ('i');    // press key i

      if (pitch == 56)
      Note = ('a');    // press key a
      if (pitch == 57)
      Note = ('s');    // press key s
      */
      if (pitch == 50)  { // apc20 Actuator Btns Row
        if(ch===1) {config.RUN_FLAG=true;       midiOutput.send([NOTE_ON + 2, 50, 0x7F]); }
        //if(ch===2) {config.OSC_DEMO_FLAG=true;  midiOutput.send([NOTE_ON + 3, 50, 0x7F]); }
        if(ch===3) {Note = ('K');}
        if(ch===4) {Note = ('-');}
        if(ch===5) {Note = ('6');}
        if(ch===6) {Note = ('1');}
        if(ch===7) { config.DemoSequence_Flag = true; }
        if(ch===8) { LFO_PHASE = 1; config.LFO_PHASE_Flag = true; }
                   
        }
    if (pitch == 49)  { // apc20 SOLO/CUE Btns Row
       // if(ch===1) {config.LFO_EN = true;}
        if(ch===2) {config.LFO_Colorthrob = true;}
        if(ch===3) {config.LFO_mvel = true;}
        if(ch===4) { config.LFO_oscVel = true; }
        if(ch===5) { config.LFO_oscDiam = true; }
        if(ch===6) { config.LFO_CX1_flag = true; }
        if(ch===7) { config.LFO_CY1_flag = true;}
        if(ch===8) { config.LFO_CX2_flag = true; }
        if(ch===1) { config.LFO_CY2_flag = true; }
   
        }
    if (pitch == 48)  { // apc20 Record Btns Row
        if(ch===1) { AltFlag[0] = true; }
        if(ch===2) { AltFlag[1] = true; }
        if(ch===3) { AltFlag[2] = true; }
        if(ch===4) { AltFlag[3] = true; }
        if(ch===5) { AltFlag[4] = true; }
        if(ch===6) { AltFlag[5] = true; }
        if(ch===7) { AltFlag[6] = true; }
        if(ch===8) { AltFlag[7] = true; }
                   
        }

     if (pitch == 53)  { // apc20 1ST ROW
        if(ch===1) {Note = ('t');}
        if(ch===2) {Note = ('q');}
        if(ch===3) {Note = ('a');}
        if(ch===4) {Note = ('g');}
        if(ch===5) {Note = ('1');}
        if(ch===6) {Note = ('6');}
        if(ch===7) {Note = ('1');}
        if(ch===8) {Note = ('6');}
                   
        }
     if (pitch == 54) { // apc20 2nd ROW
        if(ch===1) {Note = ('y');}
        if(ch===2) {Note = ('w');}
        if(ch===3) {Note = ('s');}
        if(ch===4) {Note = ('h');}
        if(ch===5) {Note = ('2');}
        if(ch===6) {Note = ('7');}
        if(ch===7) {Note = ('2');}
        if(ch===8) {Note = ('7');}
                   
        }
     if (pitch == 55)  { // apc20 3rd ROW
        if(ch===1) {Note = ('u');}
        if(ch===2) {Note = ('e');}
        if(ch===3) {Note = ('d');}
        if(ch===4) {Note = ('j');}
        if(ch===5) {Note = ('3');}
        if(ch===6) {Note = ('8');}
        if(ch===7) {Note = ('3');}
        if(ch===8) {Note = ('8');}
                   
        }
     if (pitch == 56) { // apc20 4th ROW
        if(ch===1) {Note = ('i');}
        if(ch===2) {Note = ('r');}
        if(ch===3) {Note = ('f');}
        if(ch===4) {Note = ('k');}
        if(ch===5) {Note = ('4');}
        if(ch===6) {Note = ('9');}
        if(ch===7) {Note = ('4');}
        if(ch===8) {Note = ('9');}
                   
        }
     if (pitch == 57)  { // apc20 5th ROW
        if(ch===1) {KeyHandler('t');KeyHandler('i');}
        if(ch===2) {KeyHandler('q');KeyHandler('r');}
        if(ch===3) {KeyHandler('a');KeyHandler('f');}
        if(ch===4) {KeyHandler('g');KeyHandler('k');}
        if(ch===5) {Note = ('5');}
        if(ch===6) {Note = ('0');}
        if(ch===7) {Note = ('5');}
        if(ch===8) {Note = ('0');}
                   
        }
     if (pitch == 52) { // apc20 CLIP-STOP ROW
        if(ch===1) {KeyHandler('y');KeyHandler('u');}
        if(ch===2) {KeyHandler('w');KeyHandler('e');}
        if(ch===3) {KeyHandler('s');KeyHandler('d');}
        if(ch===4) {Note = ('4');  }  
        if(ch===5) {Note = ('7');  }
        if(ch===6) {Note = ('3');}
        if(ch===7) {Note = ('2');}
        if(ch===8) {Note = ('3');}
                   
        }

    if (pitch == 81)  { location.reload() ; }    // SHIFT BTN --- RESET
    if (pitch == 82)  { Note = ('Y');   }        // press key Y - black backcolor 
    if (pitch == 83)  { Note = ('R');   }        // press key R - random backcolor
    if (pitch == 84)  { canvas.requestFullscreen(); }        
    if (pitch == 85)  { if(gui.closed) { gui.open(); gui.show(); } else { gui.close(); gui.hide(); }  }       
    if (pitch == 86)  { config.PAUSED=!config.PAUSED;   }        // press key F G H
   

    if (ch === 1 && velocity === 127)   { // MIDIMIX CONTROLLER - MUTE Row
        if(pitch==1) { config.RUN_FLAG=!config.RUN_FLAG;    }
      //  if(pitch==4) { config.OSC_DEMO_FLAG=!config.OSC_DEMO_FLAG; }
        if(pitch==7) {Note = ('K');}
        if(pitch==10) {Note = ('-');}
        if(pitch===13) { config.DemoSequence_Flag = !config.DemoSequence_Flag; }
        if(pitch===16) { config.LFO_Colorthrob = !config.LFO_Colorthrob;}
        if(pitch===19) { Note = ('R')  }  // random color
        if(pitch===22) { Note = ('Y')  }  // black color
        
        gui.updateDisplay();
        }
    if (ch === 1 && velocity === 127)  { // // MIDIMIX CONTROLLER - REC ARM Row
        if(pitch===3) { config.LFO_CX1_flag = !config.LFO_CX1_flag; }
        if(pitch===6) { config.LFO_CY1_flag = !config.LFO_CY1_flag;}
        if(pitch===9) { config.LFO_CX2_flag = !config.LFO_CX2_flag; }
        if(pitch===12) { config.LFO_CY2_flag = !config.LFO_CY2_flag; }
        if(pitch===15) { config.LFO_mvel = !config.LFO_mvel; }
        if(pitch===18) { config.LFO_oscVel = !config.LFO_oscVel; }
        if(pitch===21) { config.LFO_oscDiam = !config.LFO_oscDiam; }
        if(pitch===24) { config.LFO_Colorthrob = !config.LFO_Colorthrob; }
       
        if(pitch===27) { // Solo - map to REVERSE
            LFO_PHASE = -1; 
            config.LFO_PHASE_Flag = !config.LFO_PHASE_Flag;
            if(config.LFO_PHASE_Flag) { LFO_PHASE = 1;  }     
            }
        if(pitch==26) { if(gui.closed) { gui.open(); gui.show(); } else { gui.close(); gui.hide(); }  }  // BANK RIGHT - ASSIGNED TO SETTINGS
        if(pitch==25) { location.reload() ; }       // BANK LEFT --- RESET
        gui.updateDisplay();
        }


      //  case 36 // 24h -  assign to key   
    
      if (pitch == 36)
      Note = ('1');    // press key 1
      if (pitch == 37)
      Note = ('2');    // press key 2
      if (pitch == 38)
      Note = ('3');    // press key 3
      if (pitch == 39)
      Note = ('4');    // press key 4
      if (pitch == 40)
      Note = ('5');    // press key 5
      if (pitch == 41)
      Note = ('6');    // press key 6
      if (pitch == 42)
      Note = ('7');    // press key 7
      if (pitch == 43)
      Note = ('8');    // press key 8
      if (pitch == 44)
      Note = ('9');    // press key 9
      if (pitch == 45)
      Note = ('0');    // press key 0

      if (pitch == 46)
     
      if (pitch == 47)
      Note = ('p');    // press key p 
    
      /*
      if (pitch == 48)
      Note = ('q');    // press key q
      if (pitch == 49)
      Note = ('w');    // press key w
      if (pitch == 50)
      Note = ('e');    // press key e
        */

      if (pitch == 51)
      Note = ('r');    // press key r
    /*
      if (pitch == 52)
      Note = ('t');    // press key t
      if (pitch == 53)
      Note = ('y');    // press key y
      if (pitch == 54)
      Note = ('u');    // press key u
      if (pitch == 55)
      Note = ('i');    // press key i

      if (pitch == 56)
      Note = ('a');    // press key a
      if (pitch == 57)
      Note = ('s');    // press key s
      */
      if (pitch == 58)
      Note = ('d');    // press key d
      if (pitch == 59)
      Note = ('f');    // press key f

      if (pitch == 60)                                   // C5
      Note = ('g');    // press key g
      if (pitch == 61)
      Note = ('h');    // press key h
      if (pitch == 62)
      Note = ('j');    // press key j
      if (pitch == 63)
      Note = ('k');    // press key k

      if (pitch == 64)
      Note = ('l');    // press key l  - 
      if (pitch == 65)
      Note = (';');    // press key ;
      if (pitch == 66)
      Note = ('.');    // press key .
      if (pitch == 67)
      Note = ('/');    // press key /

      if (pitch == 68)
      Note = ('p');    // press key  
      
      if (pitch == 69)
      Note = ('c');    // press key 
      if (pitch == 70)
      Note = ('v');    // press key 
      if (pitch == 71)
      Note = ('b');    // press key  
      if (pitch == 72)                                   
      Note = ('n');    // press key  

      if (pitch == 73)
      Note = ('[');    // config.BLOOM = FALSE; ALSO TOGGLES LFO_PHASE_Flag
      if (pitch == 74)
      Note = (']');    // config.BLOOM = TRUE 
      
     if (pitch == 75)
      Note =']';// config.BLOOM = true; 
     if (pitch == 76)
      Note='['; // config.BLOOM = FALSE; ALSO TOGGLES LFO_PHASE_Flag
     
      if (pitch == 77)
      Note = ('Q');    // press key Q
      if (pitch == 78)
      Note = ('W');    // press key W
      if (pitch == 79)
      Note = ('E');    // press key E
      if (pitch == 80)
      Note = ('R');    // press key R  - bkgnd COLOR RANDOM
     /*
      if (pitch == 81)
      Note = ('F');    // press key F - bkgnd COLOR INVERT
      if (pitch == 82)
      Note = ('T');    // press key T- bkgnd COLOR INVERT
      if (pitch == 83)
      Note = ('G');    // press key G- bkgnd COLOR INVERT
      if (pitch == 84)
      Note = ('Y');    // press key Y- bkgnd COLOR BLACK
      if (pitch == 85)
      Note = ('H');    // press key H  - bkgnd COLOR INVERT
       */

      if (pitch == 86)
        Note = ('O');    // press key O - BPM
      if (pitch == 87)
        Note = ('L');    // press key L
      if (pitch == 88)
        Note = ('P');    // press key P - SPEED
      if (pitch == 89)
        Note = (':');    // press key :
      if (pitch == 90)
        Note = (' ');    // press key ' 'pause 

      if (config.MIDI_oscDiam) { config.OSC_DIAMETER = velocity; }  // data for handler
      if (config.MIDI_oscVel) { config.oscVel = velocity; }  // data for handler
      if (config.MIDI_mvel)   { config.mvel = velocity;   }  // data for handler
      KeyHandler(Note) ;        // send keypress
      gui.updateDisplay();
      UpdateAPC20_MIDI;
      console.log("Note ON Ch", ch, "MIDI NOTE:",pitch, 'Vel:' ,velocity );
 
   }   // ! note ON

   else if (cmd === CC) {
    if (pitch === 12)   {
        pointers[0].moved = true;                       // touchpad "X"
        let tempx = canvas.width*velocity/128 ;
        pointers[0].dx = (tempx - pointers[0].x) * 5.0;
        pointers[0].x = tempx;
        }

    if (pitch === 13)   {
        pointers[0].moved = true;                       // touchpad "Y"
        let tempy = canvas.height*(128-velocity)/128 ;
        pointers[0].dy = (tempy - pointers[0].y) * 5.0;
        pointers[0].y = tempy;
        }
    
    if (pitch === 47)   {           // APC20 CUE Knob INC/DEC = map to BPM
        if(ch===1)
        if(velocity>125)  {
            KeyHandler('L');            
            }
        else if (velocity <2) {
            KeyHandler('O');
            }
        gui.updateDisplay();
        }
    if (pitch === 14)   {            // APC20 MASTER Fader ch 1 = map to OSC SPEED  cnt
       config.speed=velocity/2;   
       console.log("MASTER Fader: Ch", ch, "OSC CNT SIZE:", speed);
       gui.updateDisplay();
        }

    if (pitch === 7)   {            // APC20 Fader ch 1-8 = map to 
        if(ch===1)  {
            if(!AltFlag[0]) {
                config.sdt = 0.001 + velocity/60;   // .001 - 2.90           
                console.log("Fader1:", " Step Time", config.sdt); 
            }
            else  {
                config.LFO_BPM = 0.5+velocity*120/128;   // .5 -120    
                resetLFO();       
                console.log("Fader1:", " LFO BPM", config.LFO_BPM); 
            }
        }   
        if(ch===2)  {
            if(!AltFlag[1]) {
            config.VELOCITY_DISSIPATION = 0.8 + velocity/630;   
            console.log("Fader2:", "Velocity", config.VELOCITY_DISSIPATION); 
        }
            else  {
                config.LFO_AMPLC = 1+velocity;   // 1-128           
                console.log("Fader2:", " LFO AMPLC COLOR", config.LFO_AMPLC); 
            }
        }   
        if(ch===3)  {
            if(!AltFlag[2]) {
           config.DENSITY_DISSIPATION = 0.8 + velocity/630;   
            console.log("Fader3:", "Density", config.DENSITY_DISSIPATION);  
        }
            else  {
                config.LFO_AMPL2 = 1+velocity;   // 1-128           
                console.log("Fader3:", " LFO AMPL2 mVel", config.LFO_AMPL2); 
            }
        }   
        if(ch===4)  {
            if(!AltFlag[3]) {
            config.PRESSURE_DISSIPATION = velocity/126;   
            console.log("Fader4:", "Pressure", config.PRESSURE_DISSIPATION);  
        }
            else  {
                config.LFO_AMPL3 = 1+velocity;   // 1-128           
                console.log("Fader4:", " LFO AMPL3 oscVel", config.LFO_AMPL3); 
            }
        }   
        if(ch===5)  {
            if(!AltFlag[4]) {
            config.CURL = velocity*10/127;   
            console.log("Fader5:", "Curl", config.CURL);  
        }
            else  {
                config.OSC_RADIUS = 0.01+velocity*1/128;   //.1 5.0     
                console.log("Fader5:", " OSC RADIUS", config.OSC_RADIUS); 
            }
        }   
        if(ch===6)  {
            if(!AltFlag[5]) {
           config.SPLAT_RADIUS = 0.01+velocity*1/128;   //.1 5.0
            console.log("Fader6:", "Splat Size", config.SPLAT_RADIUS);  
        }
            else  {
                config.OSC_DIAMETER = velocity;   // 1-128    
                if(!config.LFO_oscDiam) OSC_DIA_min = config.OSC_DIAMETER;       
                console.log("Fader6:", " OSC DIAMETER", config.OSC_DIAMETER); 
            }
        }   
        if(ch===7)  {
            if(!AltFlag[6]) {
           config.mvel = velocity;   
           OSC_mvel_min = config.mvel;  
            console.log("Fader7:", "MIDI Velocity", config.mvel);  
        }
            else  {
                config.DELTASIZE = 1+velocity;   // 1-128           
                console.log("Fader7:", " OSC SIZE", config.DELTASIZE); 
            }
        }   
        if(ch===8)  {
            if(!AltFlag[7]) {
            config.DELTAMULT = 0.5+velocity;   
            console.log("Fader8:", " OSC MULT", config.DELTAMULT);  
        }
            else  {
                config.oscVel = 1+velocity;   // 1-128       
                OSC_oscVel_min = config.oscVel;    
                console.log("Fader8:", " oscVel", config.oscVel); 
            }
        }   
        gui.updateDisplay();
        }  // ! Faders

    if (pitch === 16)   {           // APC20 PLAY BTNS ch 1-9 = map to 
        if(ch===1)  { console.log("PLAY:");  
            //KeyHandler('K');
            //KeyHandler('L'); 
            //KeyHandler('-'); 
            //KeyHandler('='); 
            config.RUN_FLAG=true; 
            config.OSC_DEMO_FLAG=true;
           
            }
        else if(ch===2)  { console.log("STOP:");  
            config.RUN_FLAG=false; 
            config.OSC_DEMO_FLAG=false;
            config.BKColorChangeFLAG=false;
 
            config.LFO_EN=false;
            config.LFO_Colorthrob=false;
            config.LFO_mvel=false;
 
            LFO_PHASE= -1;       // -1 or 1 --- changes spin direction
            config.LFO_PHASE_Flag = false;
           // config.RUN_FLAG=!config.RUN_FLAG; 
           // config.OSC_DEMO_FLAG=!config.OSC_DEMO_FLAG;
           
            }
        else {
             config.OSC_DEMO=7+ch;  
            }    
    
        gui.updateDisplay();
        console.log("PLAY BTNS Ch", ch );
        }  // ! pitch===16

    if (ch === 1)  {    // MIDIMIX  ch 1
        // TOP ROW KNOBS
        if (pitch === 16)   {   // MIDIMIX TOP row 1 = map to 
            config.sdt = 0.001 + velocity/60;   // .001 - 2.90           
            console.log("KNOB-TOP-1:", " Step Time", config.sdt); 
            }
        if (pitch === 20)   {   // MIDIMIX TOP row 2 = map to 
            config.VELOCITY_DISSIPATION = 0.8 + velocity/630;   
            console.log("KNOB-TOP-2:", "Velocity", config.VELOCITY_DISSIPATION); 
            }
        if (pitch === 24)   {   // MIDIMIX TOP row 3 = map to 
            config.DENSITY_DISSIPATION = 0.8 + velocity/630;   
            console.log("KNOB-TOP-3:", "Density", config.DENSITY_DISSIPATION);  
            }
        if (pitch === 28)   {   // MIDIMIX TOP row 4 = map to 
            config.PRESSURE_DISSIPATION = velocity/126;   
            console.log("KNOB-TOP-4:", "Pressure", config.PRESSURE_DISSIPATION);  
            }

        if (pitch === 46)   {   // MIDIMIX TOP row 5 = map to 
            config.CURL = velocity*10/127;   
            console.log("KNOB-TOP-5:", "Curl", config.CURL);  
            }
        if (pitch === 50)   {   // MIDIMIX TOP row 6 = map to 
            config.SPLAT_RADIUS = 0.01+velocity*1/128;   //.1 5.0
            console.log("KNOB-TOP-6:", "Splat Size", config.SPLAT_RADIUS);  
            }
        if (pitch === 54)   {   // MIDIMIX TOP row 7 = map to   
            config.mvel = velocity;   
            OSC_mvel_min = config.mvel;  
            console.log("KNOB-MID-7:", " mVel ", config.mvel); 
            }
        if (pitch === 58)   {   // MIDIMIX TOP row 8= map to 
            config.OSC_RADIUS = 0.01+velocity*1/128;   //.1 5.0  
            console.log("KNOB-MID-8:", " Osc size ", config.OSC_RADIUS); 
           
            }

    // MID ROW KNOBS
        if (pitch === 17)   {   // MIDIMIX MID row 1 = map to 
            CX1offset = -(64-velocity)*config.DELTAMULT/3;   // CENTER X1          
            console.log("KNOB-MID-1:", " CX1 offset", CX1offset); 
            }
        if (pitch === 21)   {   // MIDIMIX MID row 2 = map to 
            CY1offset = -(64-velocity)*config.DELTAMULT/3;   // CENTER Y1          
            console.log("KNOB-MID-2:", " CY1 offset", CY1offset); 
            }
        if (pitch === 25)   {   // MIDIMIX MID row 3 = map to      
            CX2offset = -(64-velocity)*config.DELTAMULT/3 ;   // CENTER X2          
            console.log("KNOB-MID-3:", " CX2 offset", CX2offset); 
            }
        if (pitch === 29)   {   // MIDIMIX MID row 4 = map to 
            CY2offset = -(64-velocity)*config.DELTAMULT/3;   // CENTER X2          
            console.log("KNOB-MID-4:", " CY2 offset", CY2offset); 
            }
          
        if (pitch === 47)   {   // MIDIMIX MID row 5 = map to 
            config.mvel = velocity; 
            OSC_mvel_min = config.mvel;    
            console.log("KNOB-MID-5:", " mVel ", config.mvel); 
            }
        if (pitch === 51)   {   // MIDIMIX MID row 6 = map to 
            config.oscVel = velocity;   
            OSC_oscVel_min = config.oscVel;  
            console.log("KNOB-MID-6:", " oscVel ", config.oscVel); 
             } 
       
        if (pitch === 55)   {   // MIDIMIX MID row 7 = map to 
            config.DELTASIZE = 1+velocity;   // 1-128           
            console.log("Fader7:", " OSC SIZE", config.DELTASIZE); 
            }
        if (pitch === 59)   {   // MIDIMIX MID row 8= map to 
            config.DELTAMULT = 0.5+velocity;   
            console.log("Fader8:", " OSC MULT", config.DELTAMULT);  
            }

 // BOT ROW KNOBS
        if (pitch === 18)   {   // MIDIMIX BOT row 1 = map to R
            config.BACK_COLOR.r =2*velocity;   // 0-254         
            console.log("KNOB-BOT-1", " BG R ", config.BACK_COLOR.r); 
            }
        if (pitch === 22)   {   // MIDIMIX BOT row 2 = map to G
            config.BACK_COLOR.g = 2*velocity;   // 0-254         
            console.log("KNOB-BOT-2:", "BG G ", config.BACK_COLOR.g);  
            }
        if (pitch === 26)   {   // MIDIMIX BOT row 3 = map to B
            config.BACK_COLOR.b = 2*velocity;   // 0-254         
            console.log("KNOB-BOT-3:", "BG B ", config.BACK_COLOR.b);  
            }
        if (pitch === 30)   {   // MIDIMIX BOT row 4 = map to LFO COLOR FACTOR
            config.LFO_AMPLC = 1+velocity;   // 1-128           
            console.log("KNOB-BOT-4:", " LFO AMPLC COLOR", config.LFO_AMPLC); 
            }

        if (pitch === 48)   {   // MIDIMIX BOT row 5 = map to 
            config.LFO_AMPL1 = 1+velocity;   // 1-128           
            console.log("KNOB-BOT-5:", " LFO AMPL1 mVel", config.LFO_AMPL1); 
            }
        if (pitch === 52)   {   // MIDIMIX BOT row 6 = map to 
            config.LFO_AMPL2 = 1+velocity;   // 1-128           
            console.log("KNOB-BOT-6:", " LFO AMPL2 oscVel", config.LFO_AMPL2); 
            }
        if (pitch === 56)   {   // MIDIMIX BOT row 7 = map to      
            config.LFO_AMPL3 = 1+velocity;   // 1-128           
            console.log("KNOB-BOT-7", " LFO AMPL3 oscDia", config.LFO_AMPL3); 
            }
        if (pitch === 60)   {   // MIDIMIX BOT row 8 = map to 
            config.LFO_AMPL4 = 1+velocity;   // 1-128           
            console.log("KNOB-BOT-8", " LFO AMPL4 oscSize", config.LFO_AMPL4); 
            }


            // FADERS
        if (pitch === 19)   {   // MIDIMIX FADER 1 = map to 
            config.LFO_BPM = 0.5+velocity*120/128;   // .5 -120    
            resetLFO();       
            console.log("Fader1:", " LFO BPM", config.LFO_BPM); 
            }    
        if (pitch === 23)   {   // MIDIMIX FADER 2 = map to 
            config.SPLAT_RADIUS = 0.01+velocity*1/128;   //.1 5.0
            console.log("Fader2:", "Splat Size", config.SPLAT_RADIUS);  
            }   
        if (pitch === 27)   {   // MIDIMIX FADER 3 = map to 
            config.mvel = velocity;   
            OSC_mvel_min = config.mvel;  
            console.log("Fader3:", " mVel ", config.mvel); 
            }
        if (pitch === 31)   {   // MIDIMIX FADER 4 = map to 
            config.speed=velocity/2;   
            console.log("Fader4:", " Speed/Size", config.speed); 
            }

        if (pitch === 49)   {   // MIDIMIX FADER 5 = map to 
            config.OSC_RADIUS = 0.01+velocity*1/128;   //.1 5.0     
            console.log("Fader5:", " OSC RADIUS", config.OSC_RADIUS); 
            }
        if (pitch === 53)   {   // MIDIMIX FADER 6 = map to 
            config.OSC_DIAMETER = velocity;   // 1-128    
            if(!config.LFO_oscDiam) OSC_DIA_min = config.OSC_DIAMETER;       
            console.log("Fader6:", " OSC DIAMETER", config.OSC_DIAMETER); 
            }
        if (pitch === 57)   {   // MIDIMIX FADER 7 = map to 
            config.DELTASIZE = 1+velocity;   // 1-128           
            console.log("Fader7:", " OSC SIZE", config.DELTASIZE); 
            }
        if (pitch === 61)   {   // MIDIMIX FADER 8 = map to 
            config.DELTAMULT = 0.5+velocity;   
            console.log("Fader8:", " OSC MULT", config.DELTAMULT);  
            }

        if (pitch === 62)   {   // MIDIMIX MASTER FADER = map to 
            config.TIME = 20+velocity*256/128;   // 20 -286    
            resetInterval();       
            console.log("MASTERFader:", " BPM", config.TIME); 
            }
    gui.updateDisplay();
      
    }  // ! MIDIMIX  ch 1

  // console.log("Ch", ch,cmd , "CC:", pitch , "VAL:", velocity);
   
  }  // !CC
  else {
    console.log("Ch", ch,cmd , "NUM:", pitch , "VAL:", velocity);
    //console.log(event);  // show raw midi
  }
}   // ! midiMessage received event

function sendMidiMessage(pitch, velocity, duration) {
  const NOTE_ON = 0x90;
  const NOTE_OFF = 0x80;
  
  const device = midiOut[selectOut.selectedIndex];
  const msgOn = [NOTE_ON, pitch, velocity];
  const msgOff = [NOTE_OFF, pitch, velocity];
  
  // First send the note on;
  device.send(msgOn); 
    
  // Then send the note off. You can send this separately if you want 
  // (i.e. when the button is released)
  device.send(msgOff, Date.now() + duration); 
}   // !SendMIDImessage


//***************************************************************

window.addEventListener('keydown', e => {
     if (e.key === ' ') {                   // space bar = pause
         config.PAUSED = !config.PAUSED;
        }
    let chr = e.key;
   // KeyHandler(chr);   /// re-map keyboard keys below!
      if (chr >= '1' && chr <= '9' || chr === '0'|| chr === '-'|| chr === '=')
      KeyHandler(chr);    // pass thru key presses
      if (chr ==='Q' || chr === 'W' || chr === 'E' || chr === 'R')
      KeyHandler(chr);    // pass thru key presses
      if (chr ==='T' || chr === 'Y' || chr === 'U' || chr === 'I')
      KeyHandler(chr);    // pass thru key presses
      if (chr ==='G' || chr === 'H' || chr === 'J' || chr === 'K')
      KeyHandler(chr);    // pass thru key presses
      if (chr ==='O' || chr === 'L' || chr === 'P' || chr === ';')
      KeyHandler(chr);    // pass thru key presses
       if(chr ==='z') { KeyHandler('q'); } 
       if(chr ==='x') { KeyHandler('w'); }
       if(chr ==='c') { KeyHandler('e'); }
       if(chr ==='v') { KeyHandler('r'); }
     
       if(chr ==='b') { KeyHandler('a'); }
       if(chr ==='n') { KeyHandler('s'); }
       if(chr ==='m') { KeyHandler('d'); }
       if(chr ===',') { KeyHandler('f'); }
       
       if(chr ==='Z') { KeyHandler('t'); } 
       if(chr ==='X') { KeyHandler('y'); }
       if(chr ==='C') { KeyHandler('u'); }
       if(chr ==='V') { KeyHandler('i'); }
     
       if(chr ==='B') { KeyHandler('g'); }
       if(chr ==='N') { KeyHandler('h'); }
       if(chr ==='M') { KeyHandler('j'); }
       if(chr ==='<') { KeyHandler('k'); }
     
      console.log("KeyHandler",  chr );

    if(chr ==='q') {  
        let p=config.BACK_COLOR.r; if(p<256) config.BACK_COLOR.r=p+1; }  //  
    if(chr ==='a')  { 
        let p=config.BACK_COLOR.r; if(p>0) config.BACK_COLOR.r=p-1; }    //
        
    if(chr ==='w') {  
        let p=config.BACK_COLOR.g; if(p<256) config.BACK_COLOR.g=p+1; }  //  
    if(chr ==='s')  { 
        let p=config.BACK_COLOR.g; if(p>0) config.BACK_COLOR.g=p-1; }    //
        
    if(chr ==='e') {  
        let p=config.BACK_COLOR.b; if(p<256) config.BACK_COLOR.b=p+1; }  //  
    if(chr ==='d')  { 
        let p=config.BACK_COLOR.b; if(p>0) config.BACK_COLOR.b=p-1; }    //
    
    if(chr ==='r') {  
        let p=config.sdt; if(p<0.200) config.sdt=p+0.001; }  //0.010  - 0.016   -  0.040 ;  
    if(chr ==='f')  { 
        let p=config.sdt; if(p>0.001) config.sdt=p-0.001; }  //0.010  - 0.016   -  0.040 ;  
     
    if(chr ==='t') {  
        let p=config.VELOCITY_DISSIPATION; if(p<2.0) config.VELOCITY_DISSIPATION=p+0.01; }  //0.97 - 1.10;  
    if(chr ==='g')  { 
        let p=config.VELOCITY_DISSIPATION; if(p>0.71) config.VELOCITY_DISSIPATION=p-0.01; }  //0.97 - 1.10;  
      
    if(chr ==='y') {  
        let p=config.DENSITY_DISSIPATION; if(p<1.0) config.DENSITY_DISSIPATION=p+0.01; }  //0.97 - 1.10;  
    if(chr ==='h')  { 
        let p=config.DENSITY_DISSIPATION; if(p>0.71) config.DENSITY_DISSIPATION=p-0.01 }  //0.97 - 1.10;  
    
    if(chr ==='u') {  
        let p=config.PRESSURE_DISSIPATION; if(p<1.02) config.PRESSURE_DISSIPATION=p+0.01; }  //0.97 - 1.10;  
    if(chr ==='j')  { 
        let p=config.PRESSURE_DISSIPATION; if(p>0.0) config.PRESSURE_DISSIPATION=p-0.01 }  //0.97 - 1.10;  
       
    if(chr ==='i') {  
        let p=config.CURL; if(p<10) config.CURL=p+0.1; }    // 0 - 10
    if(chr ==='k')  { 
        let p=config.CURL; if(p>0) config.CURL=p-0.1; }  // 0 - 10
    
    if(chr ==='o') {  
        let p=config.SPLAT_RADIUS; if(p<5.0) config.SPLAT_RADIUS=p+0.1; }    // 0.1  - 0.3  - 2.0 
    if(chr ==='l')  { 
        let p=config.SPLAT_RADIUS; if(p>0.01) config.SPLAT_RADIUS=p-0.1; }    // 0.1  - 0.3  - 2.0 
      
    if(chr ==='p') {  
        let p=config.BLOOM_INTENSITY; if(p<5.1) config.BLOOM_INTENSITY=p+0.01; }  //0.0   0.8- 1.0;  
    if(chr ===';')  { 
        let p=config.BLOOM_INTENSITY; if(p>0.0) config.BLOOM_INTENSITY=p-0.01 }  //0.0  0.8- 1.0;  
    
    if(chr ==='[') {
        config.BLOOM = false;
        if (LFO_PHASE<0) { LFO_PHASE = 1;  config.LFO_PHASE_Flag = true; }
        else  { LFO_PHASE = -1;  config.LFO_PHASE_Flag = false; }
        } 
    if(chr ===']') config.BLOOM = true;
     
    let PrintVariables = false;
    if(PrintVariables) {    
        console.log("BackgroundRGB:", config.BACK_COLOR.r, config.BACK_COLOR.g, config.BACK_COLOR.b);
       
        console.log("STEP_SIZE", config.sdt);
        console.log("VELOCITY", config.VELOCITY_DISSIPATION); 
        console.log("DENSITY", config.DENSITY_DISSIPATION);
        console.log("PRESSURE", config.PRESSURE_DISSIPATION);
        console.log("CURL", config.CURL);
        console.log("S RADIUS", config.SPLAT_RADIUS);
        console.log("OSC Radius", config.OSC_RADIUS);
        console.log("OSC MULT", config.DELTAMULT);
        
        console.log("LFO-BPM", config.LFO_BPM, 60000/config.LFO_BPM );
        console.log("LFO-AMPL-Color", config.LFO_AMPL1);
        console.log("LFO-AMPL-mVel", config.LFO_AMPL2);
        console.log("LFO-AMPL-OscVel", config.LFO_AMPL3);
        console.log("OSC RADIUS", config.OSC_RADIUS);
        console.log("OSC DIAMETER", config.OSC_DIAMETER);
        console.log("OSC SIZE", config.DELTASIZE);
        console.log("OSC VEL", config.oscVel);
      
        console.log("BPM-TIME", config.TIME, 60000/config.TIME);
        console.log("OSC-CNT,#1-12", config.speed);
    }
    gui.updateDisplay();
        
    });   // ! keydown


function KeyHandler(chr) {
 RADIUS= config.SPLAT_RADIUS ;  
 
  if (chr === '-') {
    config.OSC_DEMO_FLAG=true;
    config.OSC_DEMO =config.OSC_DEMO + 1;
    if (config.OSC_DEMO>23) { config.OSC_DEMO = 0; config.OSC_DEMO_FLAG=false;}
    UpdateAPC20_MIDI;
    gui.updateDisplay() ;
    }
 if (chr === '=') {
    config.DemoSequence_Flag = false;                                   // CHANGE DEMO #
    if(config.OSC_DEMO_FLAG) {
	    config.OSC_DEMO_FLAG=false; }
    else {
	     config.OSC_DEMO_FLAG=true; 
        }
    UpdateAPC20_MIDI;
    gui.updateDisplay() ;
    }



 if (chr === 'q')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/16;
        const y =  canvas.height/2;

        const dx = 2 * config.mvel;
        const dy =  0 ;
        splat(x, y, dx, dy, color);
    }


 if (chr === 'w')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/2;
        const y =  canvas.height*15/16;

        const dx =   0 ;
        const dy = -2 * config.mvel;
        splat(x, y, dx, dy, color);
    }


 if (chr === 'e')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/2;
        const y =  canvas.height/16;

        const dx =   0 ;
        const dy = 2 * config.mvel;
        splat(x, y, dx, dy, color);
    }


 if (chr === 'r')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width*15/16;
        const y =  canvas.height/2;

        const dx =- 2 * config.mvel;
        const dy =  0 ;
        splat(x, y, dx, dy, color);
    }






 if (chr === 't')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/2-20;
        const y =  canvas.height/2;

        const dx = -2 * config.mvel;
        const dy =  0 ;
        splat(x, y, dx, dy, color);
    }
 if (chr === 'y')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/2;
        const y =  canvas.height/2+20;

        const dy = 2 * config.mvel;
        const dx = 0;
        splat(x, y, dx, dy, color);
    }
 if (chr === 'u')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/2;
        const y =  canvas.height/2-20;

        const dx = 0;
        const dy = -2 * config.mvel;
        splat(x, y, dx, dy, color);
    }
 if (chr === 'i')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/2+20;
        const y =  canvas.height/2;

        const dx = 2 * config.mvel;
        const dy =  0 ;
        splat(x, y, dx, dy, color);
    }




 if (chr === 'a')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width/16;
        const y =  canvas.height/16;

        const dx = 2 * config.mvel;
        const dy = 2 * config.mvel;
        splat(x, y, dx, dy, color);
    }

 if (chr === 's')
 
	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        
        
        const x =  canvas.width/16;
        const y =  canvas.height*15/16;

        const dx = 2 * config.mvel;
        const dy = -2 * config.mvel;
        splat(x, y, dx, dy, color);

    }
  
 if (chr === 'd')
 

	 for (let j = 1; j < 2; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0; 
        const x =  canvas.width*15/16;
        const y =  canvas.height*15/16;
        const dx = -2 * config.mvel;
        const dy = -2 * config.mvel;
        splat(x, y, dx, dy, color);
//for (let t=0; t<255; t++)  {  x=200; }

    }
  
 if (chr === 'f')
 for (let i = 1; i < 2; i++) {

 const color = config.COLORFUL ? generateColor() : 				
 Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        
        
        const x =  canvas.width*15/16;
        const y =  canvas.height/16;

        const dx = -2 * config.mvel;
        const dy = 2 * config.mvel;
        splat(x, y, dx, dy, color);
    }
  
 if (chr === 'g')
 for (let i = 1; i < 2; i++) {

 const color = config.COLORFUL ? generateColor() : 				
 Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x =  canvas.width/2+20;
        const y =  canvas.height/2;

        const dx = -4 * config.mvel;
        const dy = -4 * config.mvel;
        splat(x, y, dx, dy, color);

    }
 
  
 if (chr === 'h')
  for (let i = 1; i < 2; i++) {

 const color = config.COLORFUL ? generateColor() : 				
 Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        
        const x =  canvas.width/2-20;
        const y =  canvas.height/2;

        const dx = -4 * config.mvel;
        const dy = 4 * config.mvel;
        splat(x, y, dx, dy, color); 

    }
  
 if (chr === 'j')  
  for (let i = 1; i < 2; i++) {

 const color = config.COLORFUL ? generateColor() : 				
 Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x =  canvas.width/2;
        const y =  canvas.height/2+20;

        const dx = 4 * config.mvel;
        const dy = 4 * config.mvel;
        splat(x, y, dx, dy, color); 

    }

 if (chr === 'k')
  for (let i = 1; i < 2; i++) {

 const color = config.COLORFUL ? generateColor() : 				
 Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        
        const x =  canvas.width/2 ;
        const y =  canvas.height/2-20;

        const dx = 4 * config.mvel;
        const dy = -4 * config.mvel;
        splat(x, y, dx, dy, color);  

    }

 if (chr === 'l')
  for (let i = 1; i < 2; i++) {

 const color = config.COLORFUL ? generateColor() : 				
 Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x =  pointers.x;
        const y =  pointers.y;
        const dx =  pointers.x-canvas.width*1/2;
        const dy = pointers.y-canvas.height*1/2;
        splat(x, y, dx, dy, color);  

    }

 
 if (chr === ';')
  for (let i = 1; i < 2; i++) {

 const color = config.COLORFUL ? generateColor() : 				
 Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x =  pointers.x;
        const y =  pointers.y;
        const dx = canvas.width*1/2-pointers.x;
        const dy = canvas.height*1/2-pointers.y;
        splat(x, y, dx, dy, color);  

    }


    if (chr === 'Q')
       //  multipleSplats(1);
       {
        const color = [{ r: 0 , g: 0 , b: 0 }];
        color.r = 12.0;
        color.g = 0.0;
        color.b = 0.0;
        const x = canvas.width * Math.random();
        const y = canvas.height * Math.random();
        const dx = y * Math.random()/10;
        const dy = x * Math.random()/10;
        splat(x, y, dx, dy, color);
       }
    if (chr === 'W')
       {
        const color = [{ r: 0 , g: 0 , b: 0 }];
        color.r = 0.0;
        color.g = 20.0;
        color.b = 0.0;
        const x = canvas.width * Math.random();
        const y = canvas.height * Math.random();
        const dx = y * Math.random()/10;
        const dy = x * Math.random()/10;
        splat(x, y, dx, dy, color);
       }
      
    if (chr === 'E')  {
        const color = [{ r: 0 , g: 0 , b: 0 }];
        color.r = 20.0;
        color.g = 10.0;
        color.b = 20.0;
        const x = canvas.width * Math.random();
        const y = canvas.height * Math.random();
        const dx = y * Math.random()/10;
        const dy = x * Math.random()/10;
        splat(x, y, dx, dy, color);
       }
  
    if (chr === 'A')
        {
        config.BACK_COLOR.r = 200.0 ;
        config.BACK_COLOR.g = 0.0 ;
        config.BACK_COLOR.b = 0.0;
       } 
   
       if (chr === 'S')
        {
        config.BACK_COLOR.r = 0.0 ;
        config.BACK_COLOR.g = 200.0 ;
        config.BACK_COLOR.b = 0.0;
       } 
    if (chr === 'D')
        {
        config.BACK_COLOR.r = 100.0 ;
        config.BACK_COLOR.g = 100.0 ;
        config.BACK_COLOR.b = 250.0;
       } 
    if (chr === 'R')
        {
        config.BACK_COLOR.r = 256 * Math.random() ;
        config.BACK_COLOR.g = 256 * Math.random() ;
        config.BACK_COLOR.b = 256 * Math.random() ;
       } 
    if (chr === 'T')
        {
        config.BACK_COLOR.r =  256 - config.BACK_COLOR.r ;
        config.BACK_COLOR.g =  256 - config.BACK_COLOR.g ;
        config.BACK_COLOR.b =  256 - config.BACK_COLOR.b ;
       } 
    if (chr === 'F')
        {
        config.BACK_COLOR.r =  256 - config.BACK_COLOR.r ;
        } 
    if (chr === 'G')
        {
        config.BACK_COLOR.g =  256 - config.BACK_COLOR.g ;
       } 
    if (chr === 'H')  {
        config.BACK_COLOR.b =  256 - config.BACK_COLOR.b ;
       } 
    if (chr === 'Y')  {
        config.BACK_COLOR.r = 0.0 ;
        config.BACK_COLOR.g = 0.0 ;
        config.BACK_COLOR.b = 0.0;
       } 
    if (chr === 'J')  {
        save();
        captureScreenshot();
        
      //  KeyHandler('U');
        } 

    if (chr === 'U')  {
       // config.TRANSPARENT = !config.TRANSPARENT ; 
        Load();
     //  save();
    } 

    if (chr === 'I')  {
        config.DemoSequence_Flag = false;                                   // CHANGE DEMO #
        config.RUN_FLAG = !config.RUN_FLAG ;
        UpdateAPC20_MIDI;
        gui.updateDisplay() ;
       } 
    if (chr === 'K')  {  
        config.DEMO_Index=config.DEMO_Index+1;
        if(config.DEMO_Index>23) { config.DEMO_Index=1;  KeyHandler('Y'); } // COLOR 
        UpdateAPC20_MIDI;
        gui.updateDisplay() ;
       } 

       if (chr === 'O')  {                 // BPM  UP
        if (config.TIME<400) { 
            config.TIME = config.TIME + 1; 
            clearInterval(myBPM);
            myBPM = setInterval(SequenceLoop,2500/config.TIME)  // loops commands = mSeconds
            console.log("BPM-TIME", config.TIME, 60000/config.TIME);
       
         }
       } 
    if (chr === 'L')  {                 // BPM DOWN

        if (config.TIME>15) { 
            config.TIME = config.TIME - 1;
            clearInterval(myBPM);
            myBPM = setInterval(SequenceLoop,2500/config.TIME)  // loops commands = mSeconds
            console.log("BPM-TIME", config.TIME, 60000/config.TIME);
       
            }
       } 
    
    if (chr === 'P')  {                 //  TIME UP 
        if (config.speed<200) { 
            config.speed = config.speed + 1; 
        } 
    }
    if (chr === ':')  {                 //  TIME DOWN 
        if (config.speed>2) { 
            config.speed = config.speed - 1; 
           }
       } 
 
   
    if (chr === '0')  {
        for (let i = 1; i < 25; i++) {
            SL_24_Patterns(20);       // call 24 times per q note
           
          //  console.log('BANG0-10');
            }
        }
   
    if (chr >= '1' && chr<='9')  {
        let Kpattern = chr-'1'+8;
        let PPQphase = 1;
        RADIUS = config.SPLAT_RADIUS+config.OSC_RADIUS; 
        for (let i = PPQphase; i < (PPQcnt+25); i=i+2) {
            SL_24_Patterns(Kpattern,i);       // call 24 times per q note
            console.log('key:', chr, 'DemoMode:', Kpattern, 'Phase:',PPQphase, i);
            }
       
        setTimeout(this, 1000);

       PPQphase = 2;
        for (let i = PPQphase; i < (PPQcnt+25); i=i+2) {
            SL_24_Patterns(Kpattern,i);       // call 24 times per q note
            console.log('key:', chr, 'DemoMode:', Kpattern, 'Phase:',PPQphase, i);
            }
        }

 
/*
if (chr === '3') 
	for (let i = 1; i < 4; i++) {

	 for (let j = 1; j < 4; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = 20 + i*220;
        const y = 100 + j*120;
        const dx = 5 * config.mvel;
        const dy = -20 * config.mvel;
        //const dx = 1000 * 0.1;
        //const dy = -1000 * 0.45;
        splat(x, y, dx, dy, color);
      //  console.log('end of KeyHandler ', chr, x, y, dx, dy, color);
    }
   }

if (chr === '4')
 for (let i = 1; i < 5; i++) {

	 for (let j = 1; j < 5; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = 20 + i*200;
        const y = 10 + j*120;
        const dx = 20 * config.mvel;
        const dy = 4 * config.mvel;
        //const dx = 1000 * 0.5;
        //const dy = 1000 * 0.1;
        splat(x, y, dx, dy, color);
    }
   }

if (chr === '5')
 for (let i = 1; i < 6; i++) {

	 for (let j = 1; j < 5; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = 20 + i*200;
        const y = 10 + j*120;
        const dx = -20 * config.mvel;
        const dy = -20 * config.mvel;
      //  const dx = -1000 * 0.5;
      //  const dy = -1000 * 0.5;
        splat(x, y, dx, dy, color);
    }
   }


if (chr === '6')
 for (let i = 1; i < 15; i++) {

	 for (let j = 1; j < 4; j++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = i*canvas.width /16;
        const y =  j*canvas.height/4;
        const dx = 2 * config.mvel;
        const dy = 0.05 * config.mvel;
        // const dx = 1000 * 0.15;
        // const dy = 1000 * 0.02;
        splat(x, y, dx, dy, color);
    }
   } 

if (chr === '7')
 
      for (let i = 1; i < 8; i++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = canvas.width/16 + i*canvas.height /10;
        const y = i*canvas.height /8;
        const dx = 20 * config.mvel;
        const dy = 20 * config.mvel;
        //const dx = 1000 * 0.5;
        //const dy = 1000 * 0.5;
        splat(x, y, dx, dy, color);
    }


if (chr === '8')
 
      for (let i = 1; i < 8; i++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = i*canvas.width /9;
        const y = i*canvas.height /10;
        const dx = 2 * config.mvel;
        const dy = 2 * config.mvel;
        //const dx = 1000 * 0.15;
        //const dy = 1000 * 0.15;
        splat(x, y, dx, dy, color);
    }



if (chr === '9')
 
      for (let i = 1; i < 8; i++) {
        const color = config.COLORFUL ? generateColor() : 				
        Object.assign({}, config.POINTER_COLOR.getRandom());
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        const x = canvas.width-50-i*canvas.width/9;
        const y = i*canvas.height/10;
        const dx = 20 * config.mvel;
        const dy = 20 * config.mvel;
        //const dx = 1000 * 0.5;
        //const dy = 1000 * 0.5;
        splat(x, y, dx, dy, color);
    }
 */  
 }   //  ! KeyHandler()


</script>
</body>
</html>

